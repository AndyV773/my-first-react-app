{"version":3,"file":"static/js/718.cbdf0b13.chunk.js","mappings":"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","sources":["utils/cryptoUtils.js","utils/fileUtils.js","workers/cryptoWorker.worker.js"],"sourcesContent":["import CryptoJS from \"crypto-js\";\r\nimport pako from \"pako\";\r\n\r\n\r\nexport const sha256 = async (data) => {\r\n\tconst buffer = await crypto.subtle.digest(\"SHA-256\", data);\r\n\treturn Array.from(new Uint8Array(buffer))\r\n\t\t.map((b) => b.toString(16).padStart(2, \"0\"))\r\n\t\t.join(\"\");\r\n};\r\n\r\n// Salt utilities\r\nexport function generateSaltBytes(length = 16) {\r\n    const array = new Uint8Array(length);\r\n    window.crypto.getRandomValues(array);\r\n    return array;\r\n}\r\n\r\nexport function bytesToHex(array) {\r\n    return Array.from(array)\r\n        .map(b => b.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\n// Convert a hexadecimal string (e.g., from SHA-256) into a byte array\r\nfunction hexToBytes(hex) {\r\n    const bytes = new Uint8Array(hex.length / 2);\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        // Parse each pair of hex digits into a byte\r\n        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);\r\n    }\r\n    return bytes;\r\n}\r\n\r\n// PRNG based on seed string\r\nfunction mulberry32(seed) {\r\n    return function () {\r\n        seed |= 0;\r\n        seed = (seed + 0x6d2b79f5) | 0;\r\n        let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);\r\n        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\r\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n    };\r\n}\r\n\r\n// Shuffle/unshuffle using deterministic PRNG\r\nfunction seededShuffle(array, key, reverse = false) {\r\n    const prng = mulberry32(\r\n        [...key].reduce((a, c) => a + c.charCodeAt(0), 0)\r\n    );\r\n    const indices = Array.from(array.keys());\r\n    for (let i = indices.length - 1; i > 0; i--) {\r\n        const j = Math.floor(prng() * (i + 1));\r\n        [indices[i], indices[j]] = [indices[j], indices[i]];\r\n    }\r\n\r\n    const result = new Uint8Array(array.length);\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (!reverse) result[i] = array[indices[i]];\r\n        else result[indices[i]] = array[i];\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Performs a deterministic shuffle of input data using a key-derived seed.\r\n * A Mulberry32 PRNG is seeded with the key + salt combination to generate a reproducible permutation.\r\n * \r\n * Note: This is not cryptographic encryption but reversible obfuscation.\r\n * \r\n * @param {Uint8Array} array - The byte array to shuffle.\r\n * @param {string} key - The key used to seed the PRNG.\r\n * @param {boolean} reverse - If true, unshuffles the data.\r\n * @returns {Uint8Array} The shuffled (or unshuffled) result.\r\n */\r\nexport function mulberryShuffle(input, key) {\r\n    if (!input) {\r\n        return { error: \"Input data.\" };\r\n    }\r\n    if (!key || key.trim() === \"\") {\r\n        return { error: \"Enter a key.\" };\r\n    }\r\n\r\n    const saltBytesKey = generateSaltBytes();\r\n    const saltBytesInput = generateSaltBytes();\r\n    const salt = bytesToHex(saltBytesKey);\r\n    const newKey = key + salt;\r\n\r\n\r\n    const newInput = new Uint8Array(input.length + saltBytesInput.length);\r\n    newInput.set(saltBytesInput, 0);                 \r\n    newInput.set(input, saltBytesInput.length); \r\n\r\n    \r\n\r\n    const shuffled = seededShuffle(newInput, newKey);\r\n\r\n    // Append salt bytes to end of shuffled data\r\n    const combined = new Uint8Array(shuffled.length + saltBytesKey.length);\r\n    combined.set(shuffled);\r\n    combined.set(saltBytesKey, shuffled.length);\r\n\r\n    return { result: combined };\r\n}\r\n\r\nexport function mulberryUnshuffle(fileInput, key) {\r\n\tif (!fileInput) {\r\n\t\treturn { error: \"Upload a file.\" };\r\n\t}\r\n\tif (!key || key.trim() === \"\") {\r\n\t\treturn { error: \"Enter a key.\" };\r\n\t}\r\n\r\n\tconst SALT_LENGTH = 16;\r\n\tif (fileInput.length <= SALT_LENGTH) {\r\n\t\treturn { error: \"Invalid file: too short.\" };\r\n\t}\r\n\r\n\tconst dataLength = fileInput.length - SALT_LENGTH;\r\n\tconst output = fileInput.slice(0, dataLength);\r\n\tconst saltBytes = fileInput.slice(dataLength);\r\n\tconst saltHex = bytesToHex(saltBytes);\r\n\tconst newKey = key + saltHex;\r\n\r\n\tconst unshuffled = seededShuffle(output, newKey, true);\r\n\r\n\tconst trimmed = unshuffled.slice(16);\r\n\r\n\treturn { result: trimmed };\r\n}\r\n\r\n\r\n/**\r\n * Encrypts a Uint8Array using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} inputBytes - The input data to encrypt.\r\n * @param {string} password - The password for encryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcEncrypt(inputBytes, password) {\r\n\tif (!inputBytes) return { error: \"No file data provided.\" };\r\n\tif (!password) return { error: \"Password is required for encryption.\" };\r\n\r\n\ttry {\r\n\t\tconst wordArray = CryptoJS.lib.WordArray.create(inputBytes);\r\n\t\tconst salt = CryptoJS.lib.WordArray.random(16);\r\n\t\tconst iv = CryptoJS.lib.WordArray.random(16);\r\n\r\n\t\tconst key = CryptoJS.PBKDF2(password, salt, {\r\n\t\tkeySize: 256 / 32,\r\n\t\titerations: 1000,\r\n\t\t});\r\n\r\n\t\tconst encrypted = CryptoJS.AES.encrypt(wordArray, key, {\r\n\t\tiv,\r\n\t\tmode: CryptoJS.mode.CBC,\r\n\t\tpadding: CryptoJS.pad.Pkcs7,\r\n\t\t});\r\n\r\n\t\t// Combine salt + IV + ciphertext\r\n\t\tconst combined = CryptoJS.lib.WordArray.create(\r\n\t\tsalt.words.concat(iv.words).concat(encrypted.ciphertext.words),\r\n\t\tsalt.sigBytes + iv.sigBytes + encrypted.ciphertext.sigBytes\r\n\t\t);\r\n\r\n\t\t// Convert to Uint8Array\r\n\t\tconst resultBytes = new Uint8Array(combined.sigBytes);\r\n\t\tfor (let i = 0; i < combined.sigBytes; i++) {\r\n\t\tresultBytes[i] = (combined.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n\t\t}\r\n\r\n\t\treturn { result: resultBytes };\r\n\t} catch (err) {\r\n\t\treturn { error: \"Encryption failed: \" + err.message };\r\n\t}\r\n}\r\n\r\n/**\r\n * Decrypts a Uint8Array encrypted using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} encryptedBytes - The encrypted input data.\r\n * @param {string} password - The password used for decryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcDecrypt(encryptedBytes, password) {\r\n\tif (!password) return { error: \"Password is required for decryption.\" };\r\n\tif (!encryptedBytes || encryptedBytes.length < 32) {\r\n\t\treturn { error: \"Invalid or incomplete encrypted data.\" };\r\n\t}\r\n\r\n\ttry {\r\n\t\t// Extract salt (16 bytes) and IV (16 bytes)\r\n\t\tconst salt = CryptoJS.lib.WordArray.create(encryptedBytes.slice(0, 16));\r\n\t\tconst iv = CryptoJS.lib.WordArray.create(encryptedBytes.slice(16, 32));\r\n\t\tconst ciphertextBytes = encryptedBytes.slice(32);\r\n\t\tconst ciphertextWords = CryptoJS.lib.WordArray.create(ciphertextBytes);\r\n\r\n\t\t// Derive key using PBKDF2\r\n\t\tconst key = CryptoJS.PBKDF2(password, salt, {\r\n\t\tkeySize: 256 / 32,\r\n\t\titerations: 1000,\r\n\t\t});\r\n\r\n\t\tconst decrypted = CryptoJS.AES.decrypt(\r\n\t\t{ ciphertext: ciphertextWords },\r\n\t\tkey,\r\n\t\t{ iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }\r\n\t\t);\r\n\r\n\t\t// Convert decrypted WordArray to Uint8Array\r\n\t\tconst resultBytes = new Uint8Array(decrypted.sigBytes);\r\n\t\tfor (let i = 0; i < decrypted.sigBytes; i++) {\r\n\t\tresultBytes[i] = (decrypted.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n\t\t}\r\n\r\n\t\treturn { result: resultBytes };\r\n\t} catch (err) {\r\n\t\treturn { error: \"Decryption failed: \" + err.message };\r\n\t}\r\n}\r\n\r\nexport function randomizer(allChar) {\r\n    const rand = Math.random() * Math.random(); // bias toward lower numbers\r\n\r\n    let value = allChar\r\n        ? Math.floor(rand * (0x10ffff + 1))\r\n        : Math.floor(rand * 10000) + 1;\r\n\r\n    // allow negative by randomly flipping sign\r\n    if (Math.random() < 0.5) value = -value;\r\n\r\n    return value;\r\n}\r\n\r\nexport function uint8ToBase64(uint8) {\r\n\tlet binary = \"\";\r\n\tconst chunkSize = 0x8000; // Avoid call stack overflow\r\n\tfor (let i = 0; i < uint8.length; i += chunkSize) {\r\n\t\tbinary += String.fromCharCode(...uint8.subarray(i, i + chunkSize));\r\n\t}\r\n\treturn btoa(binary);\r\n}\r\n\r\nexport function base64ToUint8(base64) {\r\n\tconst binary = atob(base64);\r\n\tconst len = binary.length;\r\n\tconst bytes = new Uint8Array(len);\r\n\tfor (let i = 0; i < len; i++) {\r\n\t\tbytes[i] = binary.charCodeAt(i);\r\n\t}\r\n\treturn bytes;\r\n}\r\n\r\n\r\n// text encoder helper\r\nexport function textEncoder(input) {\r\n  \treturn new TextEncoder().encode(input);\r\n}\r\n\r\n// text decoder helper\r\nexport function textDecoder(input) {\r\n  \treturn new TextDecoder().decode(input);\r\n}\r\n\r\n// pako compression helper\r\nexport function compress(input) {\r\n  \treturn pako.deflate(input);\r\n}\r\n\r\n// pako decompression help\r\nexport function decompress(input) {\r\n  \treturn pako.inflate(input);\r\n}\r\n\r\n// AES-GCM encrypt data with password, returns base64 string\r\nexport async function aesGcmEncrypt(data, password) {\r\n\tconst enc = new TextEncoder();\r\n\tconst salt = crypto.getRandomValues(new Uint8Array(16));\r\n\tconst iv = crypto.getRandomValues(new Uint8Array(12));\r\n\tconst keyMaterial = await crypto.subtle.importKey(\r\n\t\t\"raw\",\r\n\t\tenc.encode(password),\r\n\t\t{ name: \"PBKDF2\" },\r\n\t\tfalse,\r\n\t\t[\"deriveKey\"]\r\n\t);\r\n\tconst key = await crypto.subtle.deriveKey(\r\n\t\t{\r\n\t\tname: \"PBKDF2\",\r\n\t\tsalt,\r\n\t\titerations: 100000,\r\n\t\thash: \"SHA-256\",\r\n\t\t},\r\n\t\tkeyMaterial,\r\n\t\t{ name: \"AES-GCM\", length: 256 },\r\n\t\tfalse,\r\n\t\t[\"encrypt\"]\r\n\t);\r\n\r\n\tconst dataBuffer = typeof data === \"string\" ? enc.encode(data) : data;\r\n\tconst encrypted = await crypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, dataBuffer);\r\n\r\n\t// Combine salt + iv + encrypted\r\n\tconst combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);\r\n\tcombined.set(salt, 0);\r\n\tcombined.set(iv, salt.length);\r\n\tcombined.set(new Uint8Array(encrypted), salt.length + iv.length);\r\n\r\n\treturn combined;\r\n}\r\n\r\n\r\n// AES gcm Decryption\r\nexport async function aesGcmDecrypt(input, password) {\r\n    const data = input;\r\n    const salt = data.slice(0, 16);\r\n    const iv = data.slice(16, 28);\r\n    const ciphertext = data.slice(28);\r\n    const enc = new TextEncoder();\r\n    const keyMaterial = await crypto.subtle.importKey(\"raw\", enc.encode(password), { name: \"PBKDF2\" }, false, [\"deriveKey\"]);\r\n    const key = await crypto.subtle.deriveKey(\r\n\t\t{ name: \"PBKDF2\", salt, iterations: 100000, hash: \"SHA-256\" },\r\n\t\tkeyMaterial,\r\n\t\t{ name: \"AES-GCM\", length: 256 },\r\n\t\tfalse,\r\n\t\t[\"decrypt\"]\r\n    );\r\n    const decrypted = await crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, key, ciphertext);\r\n    return new Uint8Array(decrypted); // raw bytes\r\n}\r\n\r\n\r\nexport const hashArgon2 = async (input, iterations = 3, hashToVerify = null, verify = false) => {\r\n\tconst password = typeof input === \"string\" ? input : new TextDecoder().decode(input);\r\n\t\r\n\tif (verify && hashToVerify) {\r\n\t\ttry {\r\n\t\t\tconst result = await window.argon2.verify({\r\n\t\t\tpass: password,\r\n\t\t\tencoded: hashToVerify,\r\n\t\t\ttype: window.argon2.ArgonType.Argon2id,\r\n\t\t});\r\n\t\treturn result;\r\n\t\t} catch (err) {\r\n\t\tconsole.error(\"Argon2 verification error:\", err);\r\n\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tconst salt = generateSaltBytes(); \r\n\t\r\n\tconst result = await window.argon2.hash({\r\n\t\tpass: password,\r\n\t\tsalt: salt,\r\n\t\ttime: iterations,\r\n\t\tmem: 1024, // memory in KiB\r\n\t\thashLen: 32,\r\n\t\ttype: window.argon2.ArgonType.Argon2id,\r\n\t});\r\n\r\n\treturn result.encoded;\r\n};\r\n\r\nexport const rotateBytes = (bytes, keyArray) => {\r\n    const result = new Uint8Array(bytes.length);\r\n\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        result[i] = (bytes[i] + keyArray[i % keyArray.length]) & 0xff;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nexport const unrotateBytes = (bytes, keyArray) => {\r\n    const result = new Uint8Array(bytes.length);\r\n\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        result[i] = (bytes[i] - keyArray[i % keyArray.length] + 256) & 0xff;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n// Uses XOR and a hash-based key (hex string)\r\nexport function xorUint8(inputBytes, hashHex) {\r\n    const keyBytes = hexToBytes(hashHex);\r\n   \r\n    const result = new Uint8Array(inputBytes.length);\r\n    for (let i = 0; i < inputBytes.length; i++) {\r\n      // XOR again to decrypt\r\n      result[i] = inputBytes[i] ^ keyBytes[i % keyBytes.length];\r\n    }\r\n\r\n    return result; \r\n}\r\n\r\nexport const xorUint32 = (data, keyArray) => {\r\n\r\n\tconsole.log('key arry',keyArray)\r\n\tconsole.log('data in',data)\r\n\r\n    const result = new Uint32Array(data.length);\r\n\r\n    for (let i = 0; i < data.length; i++) {\r\n\r\n        result[i] = data[i] ^ keyArray[i % keyArray.length];\r\n    }\r\n\tconsole.log('data out',result)\r\n\r\n    return result;\r\n};\r\n\r\n// 32-bit rotate left\r\nfunction rol32(x, n) {\r\n  \treturn ((x << n) | (x >>> (32 - n))) >>> 0;\r\n}\r\n\r\n// 32-bit rotate right\r\nfunction ror32(x, n) {\r\n  \treturn ((x >>> n) | (x << (32 - n))) >>> 0;\r\n}\r\n\r\n// Encrypt: XOR + rotation\r\nexport function encryptXorRotate32(data, key) {\r\n\tconst result = new Uint32Array(data.length);\r\n\tfor (let i = 0; i < data.length; i++) {\r\n\t\tconst k = key[i % key.length] >>> 0;\r\n\t\tconst shift = k & 31; // use lower 5 bits (0–31) as rotation\r\n\t\tlet x = data[i] ^ k;\r\n\t\t// alternate left/right per index\r\n\t\tx = (i % 2 === 0) ? rol32(x, shift) : ror32(x, shift);\r\n\t\tresult[i] = x >>> 0;\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n// Decrypt: reverse order (undo rotation first, then XOR)\r\nexport function decryptXorRotate32(data, key) {\r\n\tconst result = new Uint32Array(data.length);\r\n\tfor (let i = 0; i < data.length; i++) {\r\n\t\tconst k = key[i % key.length] >>> 0;\r\n\t\tconst shift = k & 31;\r\n\t\tlet x = data[i];\r\n\t\t// reverse the rotation (note opposite direction)\r\n\t\tx = (i % 2 === 0) ? ror32(x, shift) : rol32(x, shift);\r\n\t\tx = x ^ k;\r\n\t\tresult[i] = x >>> 0;\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n\r\n// Random rotation generator fo uint32\r\nexport function randomizerUint32(allChar = false) {\r\n\tconst rand = Math.random() * Math.random(); // bias toward lower numbers\r\n\tlet value = allChar\r\n\t\t? Math.floor(rand * 4294967295) // full 32-bit range\r\n\t\t: Math.floor(rand * 1000000) - 1000000; \r\n\tif (Math.random() < 0.5) value = -value; // allow negative\r\n\treturn value;\r\n}\r\n\r\n// Add random padding and length markers\r\nexport function expandUint8(uint8) {\r\n\t// two random numbers [0..99]\r\n\tconst frontLen = Math.floor(Math.random() * 100);\r\n\tconst backLen = Math.floor(Math.random() * 100);\r\n\r\n\t// generate random paddings\r\n\tconst frontPad = new Uint8Array(frontLen);\r\n\tconst backPad = new Uint8Array(backLen);\r\n\tcrypto.getRandomValues(frontPad);  // cryptographically strong\r\n\tcrypto.getRandomValues(backPad);\r\n\r\n\tconst combined = new Uint8Array(frontLen + uint8.length + backLen + 2);\r\n\tcombined.set(frontPad, 0);\r\n\tcombined.set(uint8, frontLen);\r\n\tcombined.set(backPad, frontLen + uint8.length);\r\n\r\n\t// store lengths at the end\r\n\tcombined[combined.length - 2] = frontLen;\r\n\tcombined[combined.length - 1] = backLen;\r\n\r\n\treturn combined;\r\n}\r\n\r\n// Reverse the process and extract the original data\r\nexport function reduceUint8(uint8) {\r\n\tif (uint8.length < 2) throw new Error(\"Invalid data\");\r\n\r\n\tconst frontLen = uint8[uint8.length - 2];\r\n\tconst backLen = uint8[uint8.length - 1];\r\n\r\n\t// slice out the original data\r\n\tconst original = uint8.slice(frontLen, uint8.length - backLen - 2);\r\n\r\n\treturn original;\r\n}\r\n\r\n// Uint8 → Uint32, prepend length, pad to multiple of 4\r\nexport function uint8ToUint32(uint8) {\r\n\t// Prepend length (as 4 bytes)\r\n\tconst lengthArray = new Uint32Array([uint8.length]); \r\n\tconst paddedLength = Math.ceil(uint8.length / 4) * 4; // round up to multiple of 4\r\n\r\n\t// New buffer big enough for length (4 bytes) + padded data\r\n\tconst combined = new Uint8Array(4 + paddedLength);\r\n\tcombined.set(new Uint8Array(lengthArray.buffer), 0);\r\n\tcombined.set(uint8, 4);\r\n\r\n\treturn new Uint32Array(combined.buffer);\r\n}\r\n\r\n// Uint32 → Uint8, read length, trim padding\r\nexport function uint32ToUint8(uint32) {\r\n\tconst view = new DataView(uint32.buffer);\r\n\r\n\t// First 4 bytes = original length\r\n\tconst originalLength = view.getUint32(0, true);\r\n\tconst full = new Uint8Array(uint32.buffer, 4);\r\n\r\n\treturn full.slice(0, originalLength);\r\n}\r\n\r\n\r\n","import { base64ToUint8, uint8ToBase64 } from './cryptoUtils';\r\nimport JSZip from \"jszip\";\r\nimport jsQR from 'jsqr';\r\n\r\n\r\n/**\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {function(Uint8Array): void} [options.onDataLoaded]\r\n * @param {function(string): void} [options.onBase64]\r\n * @param {function({name, type, size}): void} [options.onFileInfo]\r\n * @param {function(string): void} [options.onText]\r\n */\r\nexport function uploadFile(file, options = {}) {\r\n  const {\r\n    onDataLoaded,     // function(Uint8Array): void\r\n    onBase64,         // function(base64Str): void\r\n    onFileInfo,       // function({ name, type, size }): void\r\n    onText,           // function(utf8String): void\r\n  } = options;\r\n\r\n  const reader = new FileReader();\r\n\r\n  reader.onload = async (e) => {\r\n    try {\r\n      let bytes = new Uint8Array(e.target.result);\r\n\r\n      // Call optional hooks\r\n      if (onDataLoaded) onDataLoaded(bytes);\r\n      if (onBase64) onBase64(uint8ToBase64(bytes));\r\n\r\n      if (onText) {\r\n        try {\r\n            const text = new TextDecoder().decode(bytes);\r\n            onText(text);\r\n        } catch {\r\n            onText(\"[Unreadable binary data]\");\r\n        }\r\n      }\r\n\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n            name: file.name,\r\n            type: file.type || 'unknown',\r\n            size: formatBytes(file.size),\r\n        });\r\n      }\r\n    } catch (err) {\r\n      return { error: \"Failed to process file.\" + err.message };\r\n    }\r\n  };\r\n\r\n  reader.onerror = () => {\r\n    return { error: \"Failed to read file.\" };\r\n  };\r\n\r\n  reader.readAsArrayBuffer(file);\r\n}\r\n\r\n/**\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {function(Uint8Array): void} [options.onDataLoaded]\r\n * @param {function(string): void} [options.onBase64]\r\n * @param {function({name, type, size, ext?: string}): void} [options.onFileInfo]\r\n * @param {function(string): void} [options.onText]\r\n * @param {function(Error): void} [options.onError]\r\n */\r\nexport async function uploadEncFile(file, options = {}) {\r\n  const { onDataLoaded, onBase64, onFileInfo, onText } = options;\r\n\r\n  const isImage = file.type.startsWith(\"image/\");\r\n  const reader = new FileReader();\r\n\r\n  // Helper to read ArrayBuffer or DataURL\r\n  const fileData = await new Promise((resolve, reject) => {\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject(new Error(\"Failed to read file\"));\r\n    if (isImage) {\r\n      reader.readAsDataURL(file);\r\n    } else {\r\n      reader.readAsArrayBuffer(file);\r\n    }\r\n  });\r\n\r\n  try {\r\n    let bytes;\r\n\r\n    if (isImage) {\r\n      // QR decode: await the async image load/processing\r\n      const dataUrl = fileData;\r\n      bytes = await new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.crossOrigin = \"anonymous\";\r\n        img.onload = () => {\r\n          try {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n            const ctx = canvas.getContext(\"2d\");\r\n            ctx.drawImage(img, 0, 0);\r\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n            const info = jsQR(imageData.data, canvas.width, canvas.height);\r\n            if (!info?.data) {\r\n              reject(new Error(\"Invalid or missing QR code\"));\r\n              return;\r\n            }\r\n            resolve(info.data);\r\n          } catch (err) {\r\n            reject(new Error(\"Failed to process QR image: \" + err.message));\r\n          }\r\n        };\r\n        img.onerror = () => reject(new Error(\"Failed to load image\"));\r\n        img.src = dataUrl;\r\n      });\r\n\r\n      if (onText) onText(bytes);\r\n      if (onDataLoaded) onDataLoaded(base64ToUint8(bytes));\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n          name: file.name,\r\n          type: file.type,\r\n          size: formatBytes(file.size),\r\n        });\r\n      }\r\n      return { success: true };\r\n    } else {\r\n      // Non-image (.ec) branch\r\n      bytes = new Uint8Array(fileData);\r\n\r\n      if (bytes.length < 2 || bytes[0] !== 0xEC || bytes[1] !== 0x01) {\r\n        throw new Error(\"Invalid .ec file\");\r\n      }\r\n\r\n      const data = bytes.slice(2); // strip magic\r\n\r\n      if (onDataLoaded) onDataLoaded(data);\r\n      if (onBase64) onBase64(uint8ToBase64(data));\r\n      if (onText) {\r\n        let text;\r\n        try {\r\n          text = new TextDecoder().decode(data);\r\n        } catch {\r\n          text = \"[Unreadable binary data]\";\r\n        }\r\n        onText(text);\r\n      }\r\n      \r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n          name: file.name,\r\n          type: file.type || \"application/x-ec\",\r\n          size: formatBytes(file.size),\r\n        });\r\n      }\r\n      return { success: true };\r\n    }\r\n  } catch (err) {\r\n    return { error: \"Failed to process file: \" + (err?.message || \"unknown\") };\r\n  }\r\n}\r\n\r\n// returns file size\r\nexport function formatBytes(bytes) {\r\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\r\n  if (bytes === 0) return \"0 Bytes\";\r\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\r\n  return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + \" \" + sizes[i];\r\n}\r\n\r\n// Detects file type if no result returns txt\r\nexport async function detectFileExtension(bytes) {\r\n  // Check for .ec magic number 0xEC01 (first two bytes)\r\n  if (bytes.length >= 2 && bytes[0] === 0xEC && bytes[1] === 0x01) {\r\n    return \"ec\";\r\n  }\r\n\r\n  const hex = [...bytes.slice(0, 8)]\r\n    .map((b) => b.toString(16).padStart(2, \"0\"))\r\n    .join(\"\")\r\n    .toUpperCase();\r\n\r\n  if (hex.startsWith(\"504B0304\")) {\r\n    try {\r\n      const zip = await JSZip.loadAsync(bytes);\r\n      const fileNames = Object.keys(zip.files);\r\n\r\n      if (fileNames.some(name => name.startsWith(\"word/\"))) return \"docx\";\r\n      if (fileNames.some(name => name.startsWith(\"xl/\"))) return \"xlsx\";\r\n      if (fileNames.some(name => name.startsWith(\"ppt/\"))) return \"pptx\";\r\n      \r\n      return \"zip\";\r\n    } catch (e) {\r\n      return \"zip\";\r\n    }\r\n  }\r\n\r\n  // Known binary file signatures\r\n  if (hex.startsWith(\"89504E47\")) return \"png\";\r\n  if (hex.startsWith(\"FFD8FF\")) return \"jpg\";\r\n  if (hex.startsWith(\"25504446\")) return \"pdf\";\r\n  if (hex.startsWith(\"47494638\")) return \"gif\";\r\n  if (hex.includes(\"66747970\")) return \"mp4\";\r\n  if (hex.startsWith(\"52494646\")) return \"wav\";\r\n  if (hex.startsWith(\"000001BA\")) return \"mpg\";\r\n  \r\n  // Check for binary (non-printable control characters)\r\n  const isBinary = bytes.slice(0, 512).some(\r\n    (b) =>\r\n      b < 0x09 || (b > 0x0D && b < 0x20) || b > 0x7E\r\n  );\r\n\r\n  if (isBinary) return \"bin\";\r\n\r\n  // Otherwise, decode as normal text and guess\r\n  const text = new TextDecoder().decode(bytes.slice(0, 1024)).trim();\r\n\r\n  if (text.startsWith(\"{\") || text.startsWith(\"[\")) return \"json\";\r\n  if (text.includes(\",\") && text.match(/\\n|;/)) return \"csv\";\r\n\r\n  return \"txt\";\r\n}\r\n\r\n// random number for files\r\nfunction randomNumber(max = 9999) {\r\n    const date = Date.now().toString().slice(0, 6);\r\n    const rand = Math.floor(Math.random() * max);\r\n    return date + rand;\r\n}\r\n\r\nconst fileId = randomNumber();\r\n\r\n\r\n// saves as .ec file\r\nexport function saveFileAsEc(input, name) {\r\n    if (!name) name = \"\";\r\n    // Magic number (2 bytes): 0xEC01\r\n    const MAGIC_BYTES = new Uint8Array([0xEC, 0x01]);\r\n\r\n    const blob = new Blob([MAGIC_BYTES, input], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.ec`;\r\n    a.click();\r\n}\r\n\r\n\r\n// save file as ext\r\nexport async function saveFileAsExt(input, ext, name) {\r\n    if (!name) name = \"\";\r\n    const blob = new Blob([input], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.${ext}`;\r\n    a.click();\r\n}\r\n\r\n\r\nexport function downloadQrCode(canvas, name) {\r\n    if (!name) name = \"\";\r\n    if (!(canvas instanceof HTMLCanvasElement)) return { error: \"Invalid canvas element.\" };\r\n\r\n    const link = document.createElement('a');\r\n    link.href = canvas.toDataURL('image/png');\r\n    link.download = `${name}${fileId}.png`;\r\n    link.click();    \r\n}\r\n\r\n\r\nexport function saveFileAsEc32(input, name) {\r\n    if (!name) name = \"\";\r\n\r\n    // Magic number (1 element, 32-bit): 0xEC01\r\n    const MAGIC_UINT32 = new Uint32Array([0xEC01]);\r\n\r\n    // Combine header + data into one Uint32Array\r\n    const combined = new Uint32Array(MAGIC_UINT32.length + input.length);\r\n    combined.set(MAGIC_UINT32, 0);\r\n    combined.set(input, MAGIC_UINT32.length);\r\n\r\n    // Save as raw bytes\r\n    const blob = new Blob([combined.buffer], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.ec32`; // extension for clarity\r\n    a.click();\r\n}\r\n\r\n\r\n// Upload and parse a .ec32 file (Uint32Array format with 32-bit magic).\r\nexport async function uploadEncFile32(file, options = {}) {\r\n  const { onUint32, onInt32, onText, onTextInt, onFileInfo } = options;\r\n\r\n  const reader = new FileReader();\r\n  const fileData = await new Promise((resolve, reject) => {\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject(new Error(\"Failed to read file\"));\r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n\r\n  try {\r\n    const uint32 = new Uint32Array(fileData);\r\n    const int32 = new Int32Array(fileData);\r\n\r\n    if (uint32.length < 1 || uint32[0] !== 0xEC01) {\r\n      throw new Error(\"Invalid .ec32 file (missing magic number)\");\r\n    }\r\n    if (int32.length < 1 || int32[0] !== 0xEC01) {\r\n      throw new Error(\"Invalid .ec32 file (missing magic number)\");\r\n    }\r\n\r\n    const uintData = uint32.slice(1); // strip 32-bit magic\r\n    const intKey = int32.slice(1); // strip 32-bit magic\r\n\r\n    if (onUint32) onUint32(uintData);\r\n    if (onInt32) onInt32(intKey);\r\n\r\n    if (onText) {\r\n      let text;\r\n      try {\r\n        text = new TextDecoder().decode(new Uint8Array(uintData.buffer));\r\n      } catch {\r\n        text = \"[Unreadable binary data]\";\r\n      }\r\n      onText(text);\r\n    }\r\n\r\n    if (onTextInt) {\r\n      let text;\r\n      try {\r\n        text = Array.from(intKey).join(\",\");\r\n      } catch {\r\n        text = \"[Unreadable binary data]\";\r\n      }\r\n      onTextInt(text);\r\n    }\r\n\r\n    if (onFileInfo) {\r\n      onFileInfo({\r\n        name: file.name,\r\n        type: file.type || \"application/x-ec32\",\r\n        size: file.size,\r\n        ext: \".ec32\",\r\n      });\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (err) {\r\n    return { error: \"Failed to process file: \" + (err?.message || \"unknown\") };\r\n  }\r\n}","import { randomizer, base64ToUint8, compress, decompress, aesGcmEncrypt, aesGcmDecrypt, textDecoder } from '../utils/cryptoUtils';\r\nimport { detectFileExtension } from '../utils/fileUtils';\r\n/* eslint-env worker */\r\n/* eslint-disable no-restricted-globals */\r\n\r\nself.addEventListener(\"message\", async (e) => {\r\n  const { type, load, dataPw, keyPw } = e.data;\r\n\r\n  if (type === \"shuffle\") {\r\n    const { input, allChar } = load;\r\n\r\n    let rawInput = input;\r\n    \r\n    if (!rawInput) {\r\n      return self.postMessage({ type: \"error\", error: \"No input provided.\" });\r\n    }\r\n\r\n    try {\r\n      const { shuffled, key } = quantShuffle(rawInput, allChar);\r\n      let encryptedData = \"\";\r\n      let encryptedKey = \"\";\r\n\r\n      if (dataPw && keyPw) {\r\n        try {\r\n          const compressedData = compress(shuffled);\r\n          const compressedKey = compress(key);\r\n\r\n          encryptedData = await aesGcmEncrypt(compressedData, dataPw);\r\n          encryptedKey = await aesGcmEncrypt(compressedKey, keyPw);\r\n        \r\n        } catch (err) {\r\n          self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n        }\r\n      }\r\n\r\n      self.postMessage({\r\n        type: \"done-shuffle\",\r\n        result: { shuffled, key },\r\n        encryptedData,\r\n        encryptedKey,\r\n      });\r\n    } catch (err) {\r\n      self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n    }\r\n\r\n  } else if (type === \"unshuffle\") {\r\n    let { shuffled, key } = load;\r\n\r\n    try {\r\n      if (dataPw && keyPw) {\r\n        try {\r\n          const decryptedData = await aesGcmDecrypt(shuffled, dataPw);\r\n          const decryptedKey = await aesGcmDecrypt(key, keyPw);\r\n\r\n          const decompressedData = decompress(decryptedData);\r\n          const decompressedKey = decompress(decryptedKey);\r\n\r\n          shuffled = textDecoder(decompressedData);\r\n          key = textDecoder(decompressedKey);\r\n  \r\n        } catch (err) {\r\n          self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n        }\r\n      }\r\n      const unshuffled = await quantUnshuffle(shuffled, key);\r\n      let output, ext;\r\n\r\n      try {\r\n        const bytes = base64ToUint8(unshuffled);\r\n        ext = await detectFileExtension(bytes);\r\n\r\n        if (ext !== \"bin\") {\r\n          output = base64ToUint8(unshuffled);\r\n        } else {\r\n          output = unshuffled;\r\n        }\r\n\r\n      } catch (err) {\r\n        output = unshuffled;\r\n        ext = \"txt\";\r\n      }\r\n\r\n      self.postMessage({\r\n        type: \"done-unshuffle\",\r\n        result: { output, ext},\r\n      });\r\n    } catch (err) {\r\n      self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n    }\r\n  }\r\n});\r\n\r\nfunction quantShuffle(input, allChar = false) {\r\n  const data = { shuffled: \"\", key: [] };\r\n\r\n  for (let i = 0; i < input.length; i++) {\r\n    const char = input[i];\r\n    const codePoint = char.codePointAt(0);\r\n  \r\n    let rotation, shuffledData;\r\n\r\n    do {\r\n      rotation = randomizer(allChar);\r\n      shuffledData = codePoint + rotation;\r\n    } while (\r\n      shuffledData > 0x10ffff ||\r\n      shuffledData < 0 ||\r\n      (shuffledData >= 0xd800 && shuffledData <= 0xdfff)\r\n    );\r\n\r\n    data.shuffled += String.fromCodePoint(shuffledData);\r\n    data.key.push(rotation);\r\n  }\r\n\r\n  data.key = data.key.join(\",\");\r\n\r\n  return {\r\n    shuffled: data.shuffled,\r\n    key: data.key, \r\n  };\r\n}\r\n\r\n\r\n// takes data and key and returns unshuffled data\r\nasync function quantUnshuffle(inputData, inputKey) {\r\n  const key = inputKey.split(\",\").map(Number);\r\n  let decodedString = \"\";\r\n  let i = 0;\r\n  \r\n  for (const char of inputData) {\r\n    let shuffledData = char.codePointAt(0);\r\n    let rotations = key[i++] ?? 0;\r\n    let output = (shuffledData - rotations + 0x10ffff) % 0x10ffff;\r\n    decodedString += String.fromCodePoint(output);\r\n  }\r\n\r\n  return decodedString;\r\n}"],"names":["randomizer","allChar","rand","Math","random","value","floor","base64ToUint8","base64","binary","atob","len","length","bytes","Uint8Array","i","charCodeAt","textDecoder","input","TextDecoder","decode","compress","pako","decompress","async","aesGcmEncrypt","data","password","enc","TextEncoder","salt","crypto","getRandomValues","iv","keyMaterial","subtle","importKey","encode","name","key","deriveKey","iterations","hash","dataBuffer","encrypted","encrypt","combined","byteLength","set","aesGcmDecrypt","slice","ciphertext","decrypted","decrypt","max","arguments","undefined","Date","now","toString","randomNumber","self","addEventListener","type","load","dataPw","keyPw","e","rawInput","postMessage","error","shuffled","codePoint","codePointAt","rotation","shuffledData","String","fromCodePoint","push","join","quantShuffle","encryptedData","encryptedKey","compressedData","compressedKey","err","_err$message","message","result","_err$message2","decryptedData","decryptedKey","decompressedData","decompressedKey","_err$message3","unshuffled","inputData","inputKey","split","map","Number","decodedString","char","_key$i","output","quantUnshuffle","ext","hex","b","padStart","toUpperCase","startsWith","zip","JSZip","fileNames","Object","keys","files","some","includes","text","trim","match","detectFileExtension","_err$message4"],"sourceRoot":""}