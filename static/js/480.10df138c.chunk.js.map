{"version":3,"file":"static/js/480.10df138c.chunk.js","mappings":"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","sources":["utils/cryptoUtils.js","utils/fileUtils.js","workers/cryptoWorker.worker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import CryptoJS from \"crypto-js\";\r\nimport pako from \"pako\";\r\n\r\n\r\nexport const sha256 = async (data) => {\r\n  const buffer = await crypto.subtle.digest(\"SHA-256\", data);\r\n  return Array.from(new Uint8Array(buffer))\r\n    .map((b) => b.toString(16).padStart(2, \"0\"))\r\n    .join(\"\");\r\n};\r\n\r\n// Salt utilities\r\nexport function generateSaltBytes(length = 16) {\r\n    const array = new Uint8Array(length);\r\n    window.crypto.getRandomValues(array);\r\n    return array;\r\n}\r\n\r\nexport function bytesToHex(array) {\r\n    return Array.from(array)\r\n        .map(b => b.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\n// Convert a hexadecimal string (e.g., from SHA-256) into a byte array\r\nfunction hexToBytes(hex) {\r\n    const bytes = new Uint8Array(hex.length / 2);\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        // Parse each pair of hex digits into a byte\r\n        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);\r\n    }\r\n    return bytes;\r\n}\r\n\r\n// PRNG based on seed string\r\nfunction mulberry32(seed) {\r\n    return function () {\r\n        seed |= 0;\r\n        seed = (seed + 0x6d2b79f5) | 0;\r\n        let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);\r\n        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\r\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n    };\r\n}\r\n\r\n// Shuffle/unshuffle using deterministic PRNG\r\nfunction seededShuffle(array, key, reverse = false) {\r\n    const prng = mulberry32(\r\n        [...key].reduce((a, c) => a + c.charCodeAt(0), 0)\r\n    );\r\n    const indices = Array.from(array.keys());\r\n    for (let i = indices.length - 1; i > 0; i--) {\r\n        const j = Math.floor(prng() * (i + 1));\r\n        [indices[i], indices[j]] = [indices[j], indices[i]];\r\n    }\r\n\r\n    const result = new Uint8Array(array.length);\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (!reverse) result[i] = array[indices[i]];\r\n        else result[indices[i]] = array[i];\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Performs a deterministic shuffle of input data using a key-derived seed.\r\n * A Mulberry32 PRNG is seeded with the key + salt combination to generate a reproducible permutation.\r\n * \r\n * Note: This is not cryptographic encryption but reversible obfuscation.\r\n * \r\n * @param {Uint8Array} array - The byte array to shuffle.\r\n * @param {string} key - The key used to seed the PRNG.\r\n * @param {boolean} reverse - If true, unshuffles the data.\r\n * @returns {Uint8Array} The shuffled (or unshuffled) result.\r\n */\r\nexport function mulberryShuffle(fileInput, key) {\r\n    if (!fileInput) {\r\n        return { error: \"Upload a file.\" };\r\n    }\r\n    if (!key || key.trim() === \"\") {\r\n        return { error: \"Enter a key.\" };\r\n    }\r\n\r\n    const saltBytes = generateSaltBytes();\r\n    const salt = bytesToHex(saltBytes);\r\n    const newKey = key + salt;\r\n\r\n    const shuffled = seededShuffle(fileInput, newKey);\r\n\r\n    // Append salt bytes to end of shuffled data\r\n    const combined = new Uint8Array(shuffled.length + saltBytes.length);\r\n    combined.set(shuffled);\r\n    combined.set(saltBytes, shuffled.length);\r\n\r\n    return { result: combined };\r\n}\r\n\r\nexport function mulberryUnshuffle(fileInput, key) {\r\n  if (!fileInput) {\r\n    return { error: \"Upload a file.\" };\r\n  }\r\n  if (!key || key.trim() === \"\") {\r\n    return { error: \"Enter a key.\" };\r\n  }\r\n\r\n  const SALT_LENGTH = 16;\r\n  if (fileInput.length <= SALT_LENGTH) {\r\n    return { error: \"Invalid file: too short.\" };\r\n  }\r\n\r\n  const dataLength = fileInput.length - SALT_LENGTH;\r\n  const output = fileInput.slice(0, dataLength);\r\n  const saltBytes = fileInput.slice(dataLength);\r\n  const saltHex = bytesToHex(saltBytes);\r\n  const newKey = key + saltHex;\r\n\r\n  const unshuffled = seededShuffle(output, newKey, true);\r\n\r\n  return { result: unshuffled };\r\n}\r\n\r\n\r\n/**\r\n * Encrypts a Uint8Array using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} inputBytes - The input data to encrypt.\r\n * @param {string} password - The password for encryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcEncrypt(inputBytes, password) {\r\n  if (!inputBytes) return { error: \"No file data provided.\" };\r\n  if (!password) return { error: \"Password is required for encryption.\" };\r\n\r\n  try {\r\n    const wordArray = CryptoJS.lib.WordArray.create(inputBytes);\r\n    const salt = CryptoJS.lib.WordArray.random(16);\r\n    const iv = CryptoJS.lib.WordArray.random(16);\r\n\r\n    const key = CryptoJS.PBKDF2(password, salt, {\r\n      keySize: 256 / 32,\r\n      iterations: 1000,\r\n    });\r\n\r\n    const encrypted = CryptoJS.AES.encrypt(wordArray, key, {\r\n      iv,\r\n      mode: CryptoJS.mode.CBC,\r\n      padding: CryptoJS.pad.Pkcs7,\r\n    });\r\n\r\n    // Combine salt + IV + ciphertext\r\n    const combined = CryptoJS.lib.WordArray.create(\r\n      salt.words.concat(iv.words).concat(encrypted.ciphertext.words),\r\n      salt.sigBytes + iv.sigBytes + encrypted.ciphertext.sigBytes\r\n    );\r\n\r\n    // Convert to Uint8Array\r\n    const resultBytes = new Uint8Array(combined.sigBytes);\r\n    for (let i = 0; i < combined.sigBytes; i++) {\r\n      resultBytes[i] = (combined.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n    }\r\n\r\n    return { result: resultBytes };\r\n  } catch (err) {\r\n    return { error: \"Encryption failed: \" + err.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Decrypts a Uint8Array encrypted using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} encryptedBytes - The encrypted input data.\r\n * @param {string} password - The password used for decryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcDecrypt(encryptedBytes, password) {\r\n  if (!password) return { error: \"Password is required for decryption.\" };\r\n  if (!encryptedBytes || encryptedBytes.length < 32) {\r\n    return { error: \"Invalid or incomplete encrypted data.\" };\r\n  }\r\n\r\n  try {\r\n    // Extract salt (16 bytes) and IV (16 bytes)\r\n    const salt = CryptoJS.lib.WordArray.create(encryptedBytes.slice(0, 16));\r\n    const iv = CryptoJS.lib.WordArray.create(encryptedBytes.slice(16, 32));\r\n    const ciphertextBytes = encryptedBytes.slice(32);\r\n    const ciphertextWords = CryptoJS.lib.WordArray.create(ciphertextBytes);\r\n\r\n    // Derive key using PBKDF2\r\n    const key = CryptoJS.PBKDF2(password, salt, {\r\n      keySize: 256 / 32,\r\n      iterations: 1000,\r\n    });\r\n\r\n    const decrypted = CryptoJS.AES.decrypt(\r\n      { ciphertext: ciphertextWords },\r\n      key,\r\n      { iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }\r\n    );\r\n\r\n    // Convert decrypted WordArray to Uint8Array\r\n    const resultBytes = new Uint8Array(decrypted.sigBytes);\r\n    for (let i = 0; i < decrypted.sigBytes; i++) {\r\n      resultBytes[i] = (decrypted.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n    }\r\n\r\n    return { result: resultBytes };\r\n  } catch (err) {\r\n    return { error: \"Decryption failed: \" + err.message };\r\n  }\r\n}\r\n\r\nexport function randomizer(allChar) {\r\n  const rand = Math.random() * Math.random(); // bias toward lower numbers\r\n  return allChar\r\n    ? Math.floor(rand * (0x10ffff + 1))\r\n    : Math.floor(rand * 800) + 1;\r\n}\r\n\r\nexport function uint8ToBase64(uint8) {\r\n  let binary = \"\";\r\n  const chunkSize = 0x8000; // Avoid call stack overflow\r\n  for (let i = 0; i < uint8.length; i += chunkSize) {\r\n    binary += String.fromCharCode(...uint8.subarray(i, i + chunkSize));\r\n  }\r\n  return btoa(binary);\r\n}\r\n\r\nexport function base64ToUint8(base64) {\r\n  const binary = atob(base64);\r\n  const len = binary.length;\r\n  const bytes = new Uint8Array(len);\r\n  for (let i = 0; i < len; i++) {\r\n    bytes[i] = binary.charCodeAt(i);\r\n  }\r\n  return bytes;\r\n}\r\n\r\n\r\n// text encoder helper\r\nexport function textEncoder(input) {\r\n  return new TextEncoder().encode(input);\r\n}\r\n\r\n// text decoder helper\r\nexport function textDecoder(input) {\r\n  return new TextDecoder().decode(input);\r\n}\r\n\r\n// pako compression helper\r\nexport function compress(input) {\r\n  return pako.deflate(input);\r\n}\r\n\r\n// pako decompression help\r\nexport function decompress(input) {\r\n  return pako.inflate(input);\r\n}\r\n\r\n// AES-GCM encrypt data with password, returns base64 string\r\nexport async function aesGcmEncrypt(data, password) {\r\n  const enc = new TextEncoder();\r\n  const salt = crypto.getRandomValues(new Uint8Array(16));\r\n  const iv = crypto.getRandomValues(new Uint8Array(12));\r\n  const keyMaterial = await crypto.subtle.importKey(\r\n    \"raw\",\r\n    enc.encode(password),\r\n    { name: \"PBKDF2\" },\r\n    false,\r\n    [\"deriveKey\"]\r\n  );\r\n  const key = await crypto.subtle.deriveKey(\r\n    {\r\n      name: \"PBKDF2\",\r\n      salt,\r\n      iterations: 100000,\r\n      hash: \"SHA-256\",\r\n    },\r\n    keyMaterial,\r\n    { name: \"AES-GCM\", length: 256 },\r\n    false,\r\n    [\"encrypt\"]\r\n  );\r\n\r\n  const dataBuffer = typeof data === \"string\" ? enc.encode(data) : data;\r\n  const encrypted = await crypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, dataBuffer);\r\n\r\n  // Combine salt + iv + encrypted\r\n  const combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);\r\n  combined.set(salt, 0);\r\n  combined.set(iv, salt.length);\r\n  combined.set(new Uint8Array(encrypted), salt.length + iv.length);\r\n\r\n  return combined;\r\n}\r\n\r\n\r\n// AES gcm Decryption\r\nexport async function aesGcmDecrypt(input, password) {\r\n    const data = input;\r\n    const salt = data.slice(0, 16);\r\n    const iv = data.slice(16, 28);\r\n    const ciphertext = data.slice(28);\r\n    const enc = new TextEncoder();\r\n    const keyMaterial = await crypto.subtle.importKey(\"raw\", enc.encode(password), { name: \"PBKDF2\" }, false, [\"deriveKey\"]);\r\n    const key = await crypto.subtle.deriveKey(\r\n      { name: \"PBKDF2\", salt, iterations: 100000, hash: \"SHA-256\" },\r\n      keyMaterial,\r\n      { name: \"AES-GCM\", length: 256 },\r\n      false,\r\n      [\"decrypt\"]\r\n    );\r\n    const decrypted = await crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, key, ciphertext);\r\n    return new Uint8Array(decrypted); // raw bytes\r\n}\r\n\r\n\r\nexport const hashArgon2 = async (input, iterations = 3, hashToVerify = null, verify = false) => {\r\n\r\n  const password = typeof input === \"string\" ? input : new TextDecoder().decode(input);\r\n  \r\n  if (verify && hashToVerify) {\r\n    try {\r\n        const result = await window.argon2.verify({\r\n          pass: password,\r\n          encoded: hashToVerify,\r\n          type: window.argon2.ArgonType.Argon2id,\r\n      });\r\n      return result;\r\n    } catch (err) {\r\n      console.error(\"Argon2 verification error:\", err);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  const salt = generateSaltBytes(); \r\n  \r\n  const result = await window.argon2.hash({\r\n    pass: password,\r\n    salt: salt,\r\n    time: iterations,\r\n    mem: 1024, // memory in KiB\r\n    hashLen: 32,\r\n    type: window.argon2.ArgonType.Argon2id,\r\n  });\r\n\r\n  return result.encoded;\r\n};\r\n\r\n\r\n// Encrypt text using XOR and a hash-based key (hex string)\r\n// Result is a base64-encoded string safe for storage/display\r\nexport function xorEncoder(input, hashHex) {\r\n    const textBytes = input;\r\n    const keyBytes = hexToBytes(hashHex);\r\n\r\n    const result = new Uint8Array(textBytes.length);\r\n    for (let i = 0; i < textBytes.length; i++) {\r\n      // XOR each byte of text with corresponding byte from the hash (cycled)\r\n      result[i] = textBytes[i] ^ keyBytes[i % keyBytes.length];\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// Decrypt a base64-encoded string using the same hash-based key\r\nexport function xorDecoder(inputBytes, hashHex) {\r\n    const keyBytes = hexToBytes(hashHex);\r\n   \r\n    const result = new Uint8Array(inputBytes.length);\r\n    for (let i = 0; i < inputBytes.length; i++) {\r\n      // XOR again to decrypt\r\n      result[i] = inputBytes[i] ^ keyBytes[i % keyBytes.length];\r\n    }\r\n\r\n    return result; \r\n}\r\n\r\n\r\nexport const rotateBytes = (bytes, keyArray) => {\r\n\r\n    const result = new Uint8Array(bytes.length);\r\n  \r\n    for (let i = 0; i < bytes.length; i++) {\r\n        result[i] = (bytes[i] + keyArray[i % keyArray.length]) & 0xff;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nexport const unrotateBytes = (bytes, keyArray) => {\r\n\r\n    const result = new Uint8Array(bytes.length);\r\n\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        result[i] = (bytes[i] - keyArray[i % keyArray.length] + 256) & 0xff;\r\n    }\r\n\r\n    return result;\r\n};","import { base64ToUint8, uint8ToBase64 } from './cryptoUtils';\r\nimport JSZip from \"jszip\";\r\nimport jsQR from 'jsqr';\r\n\r\n\r\n/**\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {function(Uint8Array): void} [options.onDataLoaded]\r\n * @param {function(string): void} [options.onBase64]\r\n * @param {function({name, type, size}): void} [options.onFileInfo]\r\n * @param {function(string): void} [options.onText]\r\n */\r\nexport function uploadFile(file, options = {}) {\r\n  const {\r\n    onDataLoaded,     // function(Uint8Array): void\r\n    onBase64,         // function(base64Str): void\r\n    onFileInfo,       // function({ name, type, size }): void\r\n    onText,           // function(utf8String): void\r\n  } = options;\r\n\r\n  const reader = new FileReader();\r\n\r\n  reader.onload = async (e) => {\r\n    try {\r\n      let bytes = new Uint8Array(e.target.result);\r\n\r\n      // Call optional hooks\r\n      if (onDataLoaded) onDataLoaded(bytes);\r\n      if (onBase64) onBase64(uint8ToBase64(bytes));\r\n\r\n      if (onText) {\r\n        try {\r\n            const text = new TextDecoder().decode(bytes);\r\n            onText(text);\r\n        } catch {\r\n            onText(\"[Unreadable binary data]\");\r\n        }\r\n      }\r\n\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n            name: file.name,\r\n            type: file.type || 'unknown',\r\n            size: formatBytes(file.size),\r\n        });\r\n      }\r\n    } catch (err) {\r\n      return { error: \"Failed to process file.\" + err.message };\r\n    }\r\n  };\r\n\r\n  reader.onerror = () => {\r\n    return { error: \"Failed to read file.\" };\r\n  };\r\n\r\n  reader.readAsArrayBuffer(file);\r\n}\r\n\r\n/**\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {function(Uint8Array): void} [options.onDataLoaded]\r\n * @param {function(string): void} [options.onBase64]\r\n * @param {function({name, type, size, ext?: string}): void} [options.onFileInfo]\r\n * @param {function(string): void} [options.onText]\r\n * @param {function(Error): void} [options.onError]\r\n */\r\nexport async function uploadEncFile(file, options = {}) {\r\n  const { onDataLoaded, onBase64, onFileInfo, onText } = options;\r\n\r\n  const isImage = file.type.startsWith(\"image/\");\r\n  const reader = new FileReader();\r\n\r\n  // Helper to read ArrayBuffer or DataURL\r\n  const fileData = await new Promise((resolve, reject) => {\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject(new Error(\"Failed to read file\"));\r\n    if (isImage) {\r\n      reader.readAsDataURL(file);\r\n    } else {\r\n      reader.readAsArrayBuffer(file);\r\n    }\r\n  });\r\n\r\n  try {\r\n    let bytes;\r\n\r\n    if (isImage) {\r\n      // QR decode: await the async image load/processing\r\n      const dataUrl = fileData;\r\n      bytes = await new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.crossOrigin = \"anonymous\";\r\n        img.onload = () => {\r\n          try {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n            const ctx = canvas.getContext(\"2d\");\r\n            ctx.drawImage(img, 0, 0);\r\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n            const info = jsQR(imageData.data, canvas.width, canvas.height);\r\n            if (!info?.data) {\r\n              reject(new Error(\"Invalid or missing QR code\"));\r\n              return;\r\n            }\r\n            resolve(info.data);\r\n          } catch (err) {\r\n            reject(new Error(\"Failed to process QR image: \" + err.message));\r\n          }\r\n        };\r\n        img.onerror = () => reject(new Error(\"Failed to load image\"));\r\n        img.src = dataUrl;\r\n      });\r\n\r\n      if (onText) onText(bytes);\r\n      if (onDataLoaded) onDataLoaded(base64ToUint8(bytes));\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n          name: file.name,\r\n          type: file.type,\r\n          size: formatBytes(file.size),\r\n        });\r\n      }\r\n      return { success: true };\r\n    } else {\r\n      // Non-image (.ec) branch\r\n      bytes = new Uint8Array(fileData);\r\n\r\n      if (bytes.length < 2 || bytes[0] !== 0xEC || bytes[1] !== 0x01) {\r\n        throw new Error(\"Invalid .ec file\");\r\n      }\r\n\r\n      const data = bytes.slice(2); // strip magic\r\n\r\n      if (onDataLoaded) onDataLoaded(data);\r\n      if (onBase64) onBase64(uint8ToBase64(data));\r\n      if (onText) {\r\n        let text;\r\n        try {\r\n          text = new TextDecoder().decode(data);\r\n        } catch {\r\n          text = \"[Unreadable binary data]\";\r\n        }\r\n        onText(text);\r\n      }\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n          name: file.name,\r\n          type: file.type || \"application/x-ec\",\r\n          size: formatBytes(file.size),\r\n        });\r\n      }\r\n      return { success: true };\r\n    }\r\n  } catch (err) {\r\n    return { error: \"Failed to process file: \" + (err?.message || \"unknown\") };\r\n  }\r\n}\r\n\r\n\r\n\r\n// returns file size\r\nfunction formatBytes(bytes) {\r\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\r\n  if (bytes === 0) return \"0 Bytes\";\r\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\r\n  return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + \" \" + sizes[i];\r\n}\r\n\r\n// Detects file type if no result returns txt\r\nexport async function detectFileExtension(bytes) {\r\n  // Check for .ec magic number 0xEC01 (first two bytes)\r\n  if (bytes.length >= 2 && bytes[0] === 0xEC && bytes[1] === 0x01) {\r\n    return \"ec\";\r\n  }\r\n\r\n  const hex = [...bytes.slice(0, 8)]\r\n    .map((b) => b.toString(16).padStart(2, \"0\"))\r\n    .join(\"\")\r\n    .toUpperCase();\r\n\r\n  if (hex.startsWith(\"504B0304\")) {\r\n    try {\r\n      const zip = await JSZip.loadAsync(bytes);\r\n      const fileNames = Object.keys(zip.files);\r\n\r\n      if (fileNames.some(name => name.startsWith(\"word/\"))) return \"docx\";\r\n      if (fileNames.some(name => name.startsWith(\"xl/\"))) return \"xlsx\";\r\n      if (fileNames.some(name => name.startsWith(\"ppt/\"))) return \"pptx\";\r\n      \r\n      return \"zip\";\r\n    } catch (e) {\r\n      return \"zip\";\r\n    }\r\n  }\r\n\r\n  // Known binary file signatures\r\n  if (hex.startsWith(\"89504E47\")) return \"png\";\r\n  if (hex.startsWith(\"FFD8FF\")) return \"jpg\";\r\n  if (hex.startsWith(\"25504446\")) return \"pdf\";\r\n  if (hex.startsWith(\"47494638\")) return \"gif\";\r\n  if (hex.includes(\"66747970\")) return \"mp4\";\r\n  if (hex.startsWith(\"52494646\")) return \"wav\";\r\n  if (hex.startsWith(\"000001BA\")) return \"mpg\";\r\n  \r\n  // Check for binary (non-printable control characters)\r\n  const isBinary = bytes.slice(0, 512).some(\r\n    (b) =>\r\n      b < 0x09 || (b > 0x0D && b < 0x20) || b > 0x7E\r\n  );\r\n\r\n  if (isBinary) return \"bin\";\r\n\r\n  // Otherwise, decode as normal text and guess\r\n  const text = new TextDecoder().decode(bytes.slice(0, 1024)).trim();\r\n\r\n  if (text.startsWith(\"{\") || text.startsWith(\"[\")) return \"json\";\r\n  if (text.includes(\",\") && text.match(/\\n|;/)) return \"csv\";\r\n\r\n  return \"txt\";\r\n}\r\n\r\n// random number for files\r\nfunction randomNumber(max = 9999) {\r\n    const date = Date.now().toString().slice(0, 6);\r\n    const rand = Math.floor(Math.random() * max);\r\n    return date + rand;\r\n}\r\n\r\nconst fileId = randomNumber();\r\n\r\n\r\n// saves as .ec file\r\nexport function saveFileAsEc(input, name) {\r\n    if (!name) name = \"\";\r\n    // Magic number (2 bytes): 0xEC01\r\n    const MAGIC_BYTES = new Uint8Array([0xEC, 0x01]);\r\n\r\n    const blob = new Blob([MAGIC_BYTES, input], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.ec`;\r\n    a.click();\r\n}\r\n\r\n\r\n// save file as ext\r\nexport async function saveFileAsExt(input, ext, name) {\r\n    if (!name) name = \"\";\r\n    const blob = new Blob([input], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.${ext}`;\r\n    a.click();\r\n}\r\n\r\n\r\nexport function downloadQrCode(canvas, name) {\r\n    if (!name) name = \"\";\r\n    if (!(canvas instanceof HTMLCanvasElement)) return { error: \"Invalid canvas element.\" };\r\n\r\n    const link = document.createElement('a');\r\n    link.href = canvas.toDataURL('image/png');\r\n    link.download = `${name}${fileId}.png`;\r\n    link.click();    \r\n}","import { randomizer, base64ToUint8, compress, decompress, aesGcmEncrypt, aesGcmDecrypt, textDecoder } from '../utils/cryptoUtils';\r\nimport { detectFileExtension } from '../utils/fileUtils';\r\n/* eslint-env worker */\r\n/* eslint-disable no-restricted-globals */\r\n\r\nself.addEventListener(\"message\", async (e) => {\r\n  const { type, load, dataPw, keyPw } = e.data;\r\n\r\n  if (type === \"shuffle\") {\r\n    const { input, allChar } = load;\r\n\r\n    let rawInput = input;\r\n    \r\n    if (!rawInput) {\r\n      return self.postMessage({ type: \"error\", error: \"No input provided.\" });\r\n    }\r\n\r\n    try {\r\n      const { shuffled, key } = quantShuffle(rawInput, allChar);\r\n      let encryptedData = \"\";\r\n      let encryptedKey = \"\";\r\n\r\n      if (dataPw && keyPw) {\r\n        try {\r\n          const compressedData = compress(shuffled);\r\n          const compressedKey = compress(key);\r\n\r\n          encryptedData = await aesGcmEncrypt(compressedData, dataPw);\r\n          encryptedKey = await aesGcmEncrypt(compressedKey, keyPw);\r\n        \r\n        } catch (err) {\r\n          self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n        }\r\n      }\r\n\r\n      self.postMessage({\r\n        type: \"done-shuffle\",\r\n        result: { shuffled, key },\r\n        encryptedData,\r\n        encryptedKey,\r\n      });\r\n    } catch (err) {\r\n      self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n    }\r\n\r\n  } else if (type === \"unshuffle\") {\r\n    let { shuffled, key } = load;\r\n\r\n    try {\r\n      if (dataPw && keyPw) {\r\n        try {\r\n          const decryptedData = await aesGcmDecrypt(shuffled, dataPw);\r\n          const decryptedKey = await aesGcmDecrypt(key, keyPw);\r\n\r\n          const decompressedData = decompress(decryptedData);\r\n          const decompressedKey = decompress(decryptedKey);\r\n\r\n          shuffled = textDecoder(decompressedData);\r\n          key = textDecoder(decompressedKey);\r\n  \r\n        } catch (err) {\r\n          self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n        }\r\n      }\r\n      const unshuffled = await quantUnshuffle(shuffled, key);\r\n      let output, ext;\r\n\r\n      try {\r\n        const bytes = base64ToUint8(unshuffled);\r\n        ext = await detectFileExtension(bytes);\r\n\r\n        if (ext !== \"bin\") {\r\n          output = base64ToUint8(unshuffled);\r\n        } else {\r\n          output = unshuffled;\r\n        }\r\n\r\n      } catch (err) {\r\n        output = unshuffled;\r\n        ext = \"txt\";\r\n      }\r\n\r\n      self.postMessage({\r\n        type: \"done-unshuffle\",\r\n        result: { output, ext},\r\n      });\r\n    } catch (err) {\r\n      self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n    }\r\n  }\r\n});\r\n\r\nfunction quantShuffle(input, allChar = false) {\r\n  const data = { shuffled: \"\", key: [] };\r\n\r\n  for (let i = 0; i < input.length; i++) {\r\n    const char = input[i];\r\n    const codePoint = char.codePointAt(0);\r\n  \r\n    let rotation, shuffledData;\r\n\r\n    do {\r\n      rotation = randomizer(allChar);\r\n      shuffledData = codePoint + rotation;\r\n    } while (\r\n      shuffledData > 0x10ffff ||\r\n      shuffledData < 0 ||\r\n      (shuffledData >= 0xd800 && shuffledData <= 0xdfff)\r\n    );\r\n\r\n    data.shuffled += String.fromCodePoint(shuffledData);\r\n    data.key.push(rotation);\r\n  }\r\n\r\n  data.key = data.key.join(\",\");\r\n\r\n  return {\r\n    shuffled: data.shuffled,\r\n    key: data.key, \r\n  };\r\n}\r\n\r\n\r\n// takes data and key and returns unshuffled data\r\nasync function quantUnshuffle(inputData, inputKey) {\r\n  const key = inputKey.split(\",\").map(Number);\r\n  let decodedString = \"\";\r\n  let i = 0;\r\n  \r\n  for (const char of inputData) {\r\n    let shuffledData = char.codePointAt(0);\r\n    let rotations = key[i++] ?? 0;\r\n    let output = (shuffledData - rotations + 0x10ffff) % 0x10ffff;\r\n    decodedString += String.fromCodePoint(output);\r\n  }\r\n\r\n  return decodedString;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [128], () => (__webpack_require__(7594)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"561a15bb\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/my-first-react-app/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t99: 1,\n\t337: 1,\n\t480: 1,\n\t718: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkencryption_toolkit\"] = self[\"webpackChunkencryption_toolkit\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(128).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["randomizer","allChar","rand","Math","random","floor","base64ToUint8","base64","binary","atob","len","length","bytes","Uint8Array","i","charCodeAt","textDecoder","input","TextDecoder","decode","compress","pako","decompress","async","aesGcmEncrypt","data","password","enc","TextEncoder","salt","crypto","getRandomValues","iv","keyMaterial","subtle","importKey","encode","name","key","deriveKey","iterations","hash","dataBuffer","encrypted","encrypt","combined","byteLength","set","aesGcmDecrypt","slice","ciphertext","decrypted","decrypt","max","arguments","undefined","Date","now","toString","randomNumber","self","addEventListener","type","load","dataPw","keyPw","e","rawInput","postMessage","error","shuffled","codePoint","codePointAt","rotation","shuffledData","String","fromCodePoint","push","join","quantShuffle","encryptedData","encryptedKey","compressedData","compressedKey","err","_err$message","message","result","_err$message2","decryptedData","decryptedKey","decompressedData","decompressedKey","_err$message3","unshuffled","inputData","inputKey","split","map","Number","decodedString","char","_key$i","output","quantUnshuffle","ext","hex","b","padStart","toUpperCase","startsWith","zip","JSZip","fileNames","Object","keys","files","some","includes","text","trim","match","detectFileExtension","_err$message4","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}