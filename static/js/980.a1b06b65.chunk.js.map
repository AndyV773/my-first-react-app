{"version":3,"file":"static/js/980.a1b06b65.chunk.js","mappings":"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","sources":["utils/cryptoUtils.js","utils/fileUtils.js","workers/cryptoWorkerUnit32.worker.js"],"sourcesContent":["import CryptoJS from \"crypto-js\";\r\nimport pako from \"pako\";\r\n\r\n\r\nexport const sha256 = async (data) => {\r\n\tconst buffer = await crypto.subtle.digest(\"SHA-256\", data);\r\n\treturn Array.from(new Uint8Array(buffer))\r\n\t\t.map((b) => b.toString(16).padStart(2, \"0\"))\r\n\t\t.join(\"\");\r\n};\r\n\r\n// Salt utilities\r\nexport function generateSaltBytes(length = 16) {\r\n    const array = new Uint8Array(length);\r\n    window.crypto.getRandomValues(array);\r\n    return array;\r\n}\r\n\r\nexport function bytesToHex(array) {\r\n    return Array.from(array)\r\n        .map(b => b.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\n// Convert a hexadecimal string (e.g., from SHA-256) into a byte array\r\nfunction hexToBytes(hex) {\r\n    const bytes = new Uint8Array(hex.length / 2);\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        // Parse each pair of hex digits into a byte\r\n        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);\r\n    }\r\n    return bytes;\r\n}\r\n\r\n// PRNG based on seed string\r\nfunction mulberry32(seed) {\r\n    return function () {\r\n        seed |= 0;\r\n        seed = (seed + 0x6d2b79f5) | 0;\r\n        let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);\r\n        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\r\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n    };\r\n}\r\n\r\n// Shuffle/unshuffle using deterministic PRNG\r\nfunction seededShuffle(array, key, reverse = false) {\r\n    const prng = mulberry32(\r\n        [...key].reduce((a, c) => a + c.charCodeAt(0), 0)\r\n    );\r\n    const indices = Array.from(array.keys());\r\n    for (let i = indices.length - 1; i > 0; i--) {\r\n        const j = Math.floor(prng() * (i + 1));\r\n        [indices[i], indices[j]] = [indices[j], indices[i]];\r\n    }\r\n\r\n    const result = new Uint8Array(array.length);\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (!reverse) result[i] = array[indices[i]];\r\n        else result[indices[i]] = array[i];\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Performs a deterministic shuffle of input data using a key-derived seed.\r\n * A Mulberry32 PRNG is seeded with the key + salt combination to generate a reproducible permutation.\r\n * \r\n * Note: This is not cryptographic encryption but reversible obfuscation.\r\n * \r\n * @param {Uint8Array} array - The byte array to shuffle.\r\n * @param {string} key - The key used to seed the PRNG.\r\n * @param {boolean} reverse - If true, unshuffles the data.\r\n * @returns {Uint8Array} The shuffled (or unshuffled) result.\r\n */\r\nexport function mulberryShuffle(input, key) {\r\n    if (!input) {\r\n        return { error: \"Input data.\" };\r\n    }\r\n    if (!key || key.trim() === \"\") {\r\n        return { error: \"Enter a key.\" };\r\n    }\r\n\r\n    const saltBytesKey = generateSaltBytes();\r\n    const saltBytesInput = generateSaltBytes();\r\n    const salt = bytesToHex(saltBytesKey);\r\n    const newKey = key + salt;\r\n\r\n\r\n    const newInput = new Uint8Array(input.length + saltBytesInput.length);\r\n    newInput.set(saltBytesInput, 0);                 \r\n    newInput.set(input, saltBytesInput.length); \r\n\r\n    \r\n\r\n    const shuffled = seededShuffle(newInput, newKey);\r\n\r\n    // Append salt bytes to end of shuffled data\r\n    const combined = new Uint8Array(shuffled.length + saltBytesKey.length);\r\n    combined.set(shuffled);\r\n    combined.set(saltBytesKey, shuffled.length);\r\n\r\n    return { result: combined };\r\n}\r\n\r\nexport function mulberryUnshuffle(fileInput, key) {\r\n\tif (!fileInput) {\r\n\t\treturn { error: \"Upload a file.\" };\r\n\t}\r\n\tif (!key || key.trim() === \"\") {\r\n\t\treturn { error: \"Enter a key.\" };\r\n\t}\r\n\r\n\tconst SALT_LENGTH = 16;\r\n\tif (fileInput.length <= SALT_LENGTH) {\r\n\t\treturn { error: \"Invalid file: too short.\" };\r\n\t}\r\n\r\n\tconst dataLength = fileInput.length - SALT_LENGTH;\r\n\tconst output = fileInput.slice(0, dataLength);\r\n\tconst saltBytes = fileInput.slice(dataLength);\r\n\tconst saltHex = bytesToHex(saltBytes);\r\n\tconst newKey = key + saltHex;\r\n\r\n\tconst unshuffled = seededShuffle(output, newKey, true);\r\n\r\n\tconst trimmed = unshuffled.slice(16);\r\n\r\n\treturn { result: trimmed };\r\n}\r\n\r\n\r\n/**\r\n * Encrypts a Uint8Array using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} inputBytes - The input data to encrypt.\r\n * @param {string} password - The password for encryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcEncrypt(inputBytes, password) {\r\n\tif (!inputBytes) return { error: \"No file data provided.\" };\r\n\tif (!password) return { error: \"Password is required for encryption.\" };\r\n\r\n\ttry {\r\n\t\tconst wordArray = CryptoJS.lib.WordArray.create(inputBytes);\r\n\t\tconst salt = CryptoJS.lib.WordArray.random(16);\r\n\t\tconst iv = CryptoJS.lib.WordArray.random(16);\r\n\r\n\t\tconst key = CryptoJS.PBKDF2(password, salt, {\r\n\t\tkeySize: 256 / 32,\r\n\t\titerations: 1000,\r\n\t\t});\r\n\r\n\t\tconst encrypted = CryptoJS.AES.encrypt(wordArray, key, {\r\n\t\tiv,\r\n\t\tmode: CryptoJS.mode.CBC,\r\n\t\tpadding: CryptoJS.pad.Pkcs7,\r\n\t\t});\r\n\r\n\t\t// Combine salt + IV + ciphertext\r\n\t\tconst combined = CryptoJS.lib.WordArray.create(\r\n\t\tsalt.words.concat(iv.words).concat(encrypted.ciphertext.words),\r\n\t\tsalt.sigBytes + iv.sigBytes + encrypted.ciphertext.sigBytes\r\n\t\t);\r\n\r\n\t\t// Convert to Uint8Array\r\n\t\tconst resultBytes = new Uint8Array(combined.sigBytes);\r\n\t\tfor (let i = 0; i < combined.sigBytes; i++) {\r\n\t\tresultBytes[i] = (combined.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n\t\t}\r\n\r\n\t\treturn { result: resultBytes };\r\n\t} catch (err) {\r\n\t\treturn { error: \"Encryption failed: \" + err.message };\r\n\t}\r\n}\r\n\r\n/**\r\n * Decrypts a Uint8Array encrypted using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} encryptedBytes - The encrypted input data.\r\n * @param {string} password - The password used for decryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcDecrypt(encryptedBytes, password) {\r\n\tif (!password) return { error: \"Password is required for decryption.\" };\r\n\tif (!encryptedBytes || encryptedBytes.length < 32) {\r\n\t\treturn { error: \"Invalid or incomplete encrypted data.\" };\r\n\t}\r\n\r\n\ttry {\r\n\t\t// Extract salt (16 bytes) and IV (16 bytes)\r\n\t\tconst salt = CryptoJS.lib.WordArray.create(encryptedBytes.slice(0, 16));\r\n\t\tconst iv = CryptoJS.lib.WordArray.create(encryptedBytes.slice(16, 32));\r\n\t\tconst ciphertextBytes = encryptedBytes.slice(32);\r\n\t\tconst ciphertextWords = CryptoJS.lib.WordArray.create(ciphertextBytes);\r\n\r\n\t\t// Derive key using PBKDF2\r\n\t\tconst key = CryptoJS.PBKDF2(password, salt, {\r\n\t\tkeySize: 256 / 32,\r\n\t\titerations: 1000,\r\n\t\t});\r\n\r\n\t\tconst decrypted = CryptoJS.AES.decrypt(\r\n\t\t{ ciphertext: ciphertextWords },\r\n\t\tkey,\r\n\t\t{ iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }\r\n\t\t);\r\n\r\n\t\t// Convert decrypted WordArray to Uint8Array\r\n\t\tconst resultBytes = new Uint8Array(decrypted.sigBytes);\r\n\t\tfor (let i = 0; i < decrypted.sigBytes; i++) {\r\n\t\tresultBytes[i] = (decrypted.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n\t\t}\r\n\r\n\t\treturn { result: resultBytes };\r\n\t} catch (err) {\r\n\t\treturn { error: \"Decryption failed: \" + err.message };\r\n\t}\r\n}\r\n\r\nexport function randomizer(allChar) {\r\n    const rand = Math.random() * Math.random(); // bias toward lower numbers\r\n\r\n    let value = allChar\r\n        ? Math.floor(rand * (0x10ffff + 1))\r\n        : Math.floor(rand * 10000) + 1;\r\n\r\n    // allow negative by randomly flipping sign\r\n    if (Math.random() < 0.5) value = -value;\r\n\r\n    return value;\r\n}\r\n\r\nexport function uint8ToBase64(uint8) {\r\n\tlet binary = \"\";\r\n\tconst chunkSize = 0x8000; // Avoid call stack overflow\r\n\tfor (let i = 0; i < uint8.length; i += chunkSize) {\r\n\t\tbinary += String.fromCharCode(...uint8.subarray(i, i + chunkSize));\r\n\t}\r\n\treturn btoa(binary);\r\n}\r\n\r\nexport function base64ToUint8(base64) {\r\n\tconst binary = atob(base64);\r\n\tconst len = binary.length;\r\n\tconst bytes = new Uint8Array(len);\r\n\tfor (let i = 0; i < len; i++) {\r\n\t\tbytes[i] = binary.charCodeAt(i);\r\n\t}\r\n\treturn bytes;\r\n}\r\n\r\n\r\n// text encoder helper\r\nexport function textEncoder(input) {\r\n  \treturn new TextEncoder().encode(input);\r\n}\r\n\r\n// text decoder helper\r\nexport function textDecoder(input) {\r\n  \treturn new TextDecoder().decode(input);\r\n}\r\n\r\n// pako compression helper\r\nexport function compress(input) {\r\n  \treturn pako.deflate(input);\r\n}\r\n\r\n// pako decompression help\r\nexport function decompress(input) {\r\n  \treturn pako.inflate(input);\r\n}\r\n\r\n// AES-GCM encrypt data with password, returns base64 string\r\nexport async function aesGcmEncrypt(data, password) {\r\n\tconst enc = new TextEncoder();\r\n\tconst salt = crypto.getRandomValues(new Uint8Array(16));\r\n\tconst iv = crypto.getRandomValues(new Uint8Array(12));\r\n\tconst keyMaterial = await crypto.subtle.importKey(\r\n\t\t\"raw\",\r\n\t\tenc.encode(password),\r\n\t\t{ name: \"PBKDF2\" },\r\n\t\tfalse,\r\n\t\t[\"deriveKey\"]\r\n\t);\r\n\tconst key = await crypto.subtle.deriveKey(\r\n\t\t{\r\n\t\tname: \"PBKDF2\",\r\n\t\tsalt,\r\n\t\titerations: 100000,\r\n\t\thash: \"SHA-256\",\r\n\t\t},\r\n\t\tkeyMaterial,\r\n\t\t{ name: \"AES-GCM\", length: 256 },\r\n\t\tfalse,\r\n\t\t[\"encrypt\"]\r\n\t);\r\n\r\n\tconst dataBuffer = typeof data === \"string\" ? enc.encode(data) : data;\r\n\tconst encrypted = await crypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, dataBuffer);\r\n\r\n\t// Combine salt + iv + encrypted\r\n\tconst combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);\r\n\tcombined.set(salt, 0);\r\n\tcombined.set(iv, salt.length);\r\n\tcombined.set(new Uint8Array(encrypted), salt.length + iv.length);\r\n\r\n\treturn combined;\r\n}\r\n\r\n\r\n// AES gcm Decryption\r\nexport async function aesGcmDecrypt(input, password) {\r\n    const data = input;\r\n    const salt = data.slice(0, 16);\r\n    const iv = data.slice(16, 28);\r\n    const ciphertext = data.slice(28);\r\n    const enc = new TextEncoder();\r\n    const keyMaterial = await crypto.subtle.importKey(\"raw\", enc.encode(password), { name: \"PBKDF2\" }, false, [\"deriveKey\"]);\r\n    const key = await crypto.subtle.deriveKey(\r\n\t\t{ name: \"PBKDF2\", salt, iterations: 100000, hash: \"SHA-256\" },\r\n\t\tkeyMaterial,\r\n\t\t{ name: \"AES-GCM\", length: 256 },\r\n\t\tfalse,\r\n\t\t[\"decrypt\"]\r\n    );\r\n    const decrypted = await crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, key, ciphertext);\r\n    return new Uint8Array(decrypted); // raw bytes\r\n}\r\n\r\n\r\nexport const hashArgon2 = async (input, iterations = 3, hashToVerify = null, verify = false) => {\r\n\tconst password = typeof input === \"string\" ? input : new TextDecoder().decode(input);\r\n\t\r\n\tif (verify && hashToVerify) {\r\n\t\ttry {\r\n\t\t\tconst result = await window.argon2.verify({\r\n\t\t\tpass: password,\r\n\t\t\tencoded: hashToVerify,\r\n\t\t\ttype: window.argon2.ArgonType.Argon2id,\r\n\t\t});\r\n\t\treturn result;\r\n\t\t} catch (err) {\r\n\t\tconsole.error(\"Argon2 verification error:\", err);\r\n\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tconst salt = generateSaltBytes(); \r\n\t\r\n\tconst result = await window.argon2.hash({\r\n\t\tpass: password,\r\n\t\tsalt: salt,\r\n\t\ttime: iterations,\r\n\t\tmem: 1024, // memory in KiB\r\n\t\thashLen: 32,\r\n\t\ttype: window.argon2.ArgonType.Argon2id,\r\n\t});\r\n\r\n\treturn result.encoded;\r\n};\r\n\r\nexport const rotateBytes = (bytes, keyArray) => {\r\n    const result = new Uint8Array(bytes.length);\r\n\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        result[i] = (bytes[i] + keyArray[i % keyArray.length]) & 0xff;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nexport const unrotateBytes = (bytes, keyArray) => {\r\n    const result = new Uint8Array(bytes.length);\r\n\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        result[i] = (bytes[i] - keyArray[i % keyArray.length] + 256) & 0xff;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n// Uses XOR and a hash-based key (hex string)\r\nexport function xorUint8(inputBytes, hashHex) {\r\n    const keyBytes = hexToBytes(hashHex);\r\n   \r\n    const result = new Uint8Array(inputBytes.length);\r\n    for (let i = 0; i < inputBytes.length; i++) {\r\n      // XOR again to decrypt\r\n      result[i] = inputBytes[i] ^ keyBytes[i % keyBytes.length];\r\n    }\r\n\r\n    return result; \r\n}\r\n\r\nexport const xorUint32 = (data, keyArray) => {\r\n\r\n\tconsole.log('key arry',keyArray)\r\n\tconsole.log('data in',data)\r\n\r\n    const result = new Uint32Array(data.length);\r\n\r\n    for (let i = 0; i < data.length; i++) {\r\n\r\n        result[i] = data[i] ^ keyArray[i % keyArray.length];\r\n    }\r\n\tconsole.log('data out',result)\r\n\r\n    return result;\r\n};\r\n\r\n// 32-bit rotate left\r\nfunction rol32(x, n) {\r\n  \treturn ((x << n) | (x >>> (32 - n))) >>> 0;\r\n}\r\n\r\n// 32-bit rotate right\r\nfunction ror32(x, n) {\r\n  \treturn ((x >>> n) | (x << (32 - n))) >>> 0;\r\n}\r\n\r\n// Encrypt: XOR + rotation\r\nexport function encryptXorRotate32(data, key) {\r\n\tconst result = new Uint32Array(data.length);\r\n\tfor (let i = 0; i < data.length; i++) {\r\n\t\tconst k = key[i % key.length] >>> 0;\r\n\t\tconst shift = k & 31; // use lower 5 bits (0–31) as rotation\r\n\t\tlet x = data[i] ^ k;\r\n\t\t// alternate left/right per index\r\n\t\tx = (i % 2 === 0) ? rol32(x, shift) : ror32(x, shift);\r\n\t\tresult[i] = x >>> 0;\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n// Decrypt: reverse order (undo rotation first, then XOR)\r\nexport function decryptXorRotate32(data, key) {\r\n\tconst result = new Uint32Array(data.length);\r\n\tfor (let i = 0; i < data.length; i++) {\r\n\t\tconst k = key[i % key.length] >>> 0;\r\n\t\tconst shift = k & 31;\r\n\t\tlet x = data[i];\r\n\t\t// reverse the rotation (note opposite direction)\r\n\t\tx = (i % 2 === 0) ? ror32(x, shift) : rol32(x, shift);\r\n\t\tx = x ^ k;\r\n\t\tresult[i] = x >>> 0;\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n\r\n// Random rotation generator fo uint32\r\nexport function randomizerUint32(allChar = false) {\r\n\tconst rand = Math.random() * Math.random(); // bias toward lower numbers\r\n\tlet value = allChar\r\n\t\t? Math.floor(rand * 4294967295) // full 32-bit range\r\n\t\t: Math.floor(rand * 1000000) - 1000000; \r\n\tif (Math.random() < 0.5) value = -value; // allow negative\r\n\treturn value;\r\n}\r\n\r\n// Add random padding and length markers\r\nexport function expandUint8(uint8) {\r\n\t// two random numbers [0..99]\r\n\tconst frontLen = Math.floor(Math.random() * 100);\r\n\tconst backLen = Math.floor(Math.random() * 100);\r\n\r\n\t// generate random paddings\r\n\tconst frontPad = new Uint8Array(frontLen);\r\n\tconst backPad = new Uint8Array(backLen);\r\n\tcrypto.getRandomValues(frontPad);  // cryptographically strong\r\n\tcrypto.getRandomValues(backPad);\r\n\r\n\tconst combined = new Uint8Array(frontLen + uint8.length + backLen + 2);\r\n\tcombined.set(frontPad, 0);\r\n\tcombined.set(uint8, frontLen);\r\n\tcombined.set(backPad, frontLen + uint8.length);\r\n\r\n\t// store lengths at the end\r\n\tcombined[combined.length - 2] = frontLen;\r\n\tcombined[combined.length - 1] = backLen;\r\n\r\n\treturn combined;\r\n}\r\n\r\n// Reverse the process and extract the original data\r\nexport function reduceUint8(uint8) {\r\n\tif (uint8.length < 2) throw new Error(\"Invalid data\");\r\n\r\n\tconst frontLen = uint8[uint8.length - 2];\r\n\tconst backLen = uint8[uint8.length - 1];\r\n\r\n\t// slice out the original data\r\n\tconst original = uint8.slice(frontLen, uint8.length - backLen - 2);\r\n\r\n\treturn original;\r\n}\r\n\r\n// Uint8 → Uint32, prepend length, pad to multiple of 4\r\nexport function uint8ToUint32(uint8) {\r\n\t// Prepend length (as 4 bytes)\r\n\tconst lengthArray = new Uint32Array([uint8.length]); \r\n\tconst paddedLength = Math.ceil(uint8.length / 4) * 4; // round up to multiple of 4\r\n\r\n\t// New buffer big enough for length (4 bytes) + padded data\r\n\tconst combined = new Uint8Array(4 + paddedLength);\r\n\tcombined.set(new Uint8Array(lengthArray.buffer), 0);\r\n\tcombined.set(uint8, 4);\r\n\r\n\treturn new Uint32Array(combined.buffer);\r\n}\r\n\r\n// Uint32 → Uint8, read length, trim padding\r\nexport function uint32ToUint8(uint32) {\r\n\tconst view = new DataView(uint32.buffer);\r\n\r\n\t// First 4 bytes = original length\r\n\tconst originalLength = view.getUint32(0, true);\r\n\tconst full = new Uint8Array(uint32.buffer, 4);\r\n\r\n\treturn full.slice(0, originalLength);\r\n}\r\n\r\n\r\n","import { base64ToUint8, uint8ToBase64 } from './cryptoUtils';\r\nimport JSZip from \"jszip\";\r\nimport jsQR from 'jsqr';\r\n\r\n\r\n/**\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {function(Uint8Array): void} [options.onDataLoaded]\r\n * @param {function(string): void} [options.onBase64]\r\n * @param {function({name, type, size}): void} [options.onFileInfo]\r\n * @param {function(string): void} [options.onText]\r\n */\r\nexport function uploadFile(file, options = {}) {\r\n  const {\r\n    onDataLoaded,     // function(Uint8Array): void\r\n    onBase64,         // function(base64Str): void\r\n    onFileInfo,       // function({ name, type, size }): void\r\n    onText,           // function(utf8String): void\r\n  } = options;\r\n\r\n  const reader = new FileReader();\r\n\r\n  reader.onload = async (e) => {\r\n    try {\r\n      let bytes = new Uint8Array(e.target.result);\r\n\r\n      // Call optional hooks\r\n      if (onDataLoaded) onDataLoaded(bytes);\r\n      if (onBase64) onBase64(uint8ToBase64(bytes));\r\n\r\n      if (onText) {\r\n        try {\r\n            const text = new TextDecoder().decode(bytes);\r\n            onText(text);\r\n        } catch {\r\n            onText(\"[Unreadable binary data]\");\r\n        }\r\n      }\r\n\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n            name: file.name,\r\n            type: file.type || 'unknown',\r\n            size: formatBytes(file.size),\r\n        });\r\n      }\r\n    } catch (err) {\r\n      return { error: \"Failed to process file.\" + err.message };\r\n    }\r\n  };\r\n\r\n  reader.onerror = () => {\r\n    return { error: \"Failed to read file.\" };\r\n  };\r\n\r\n  reader.readAsArrayBuffer(file);\r\n}\r\n\r\n/**\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {function(Uint8Array): void} [options.onDataLoaded]\r\n * @param {function(string): void} [options.onBase64]\r\n * @param {function({name, type, size, ext?: string}): void} [options.onFileInfo]\r\n * @param {function(string): void} [options.onText]\r\n * @param {function(Error): void} [options.onError]\r\n */\r\nexport async function uploadEncFile(file, options = {}) {\r\n  const { onDataLoaded, onBase64, onFileInfo, onText } = options;\r\n\r\n  const isImage = file.type.startsWith(\"image/\");\r\n  const reader = new FileReader();\r\n\r\n  // Helper to read ArrayBuffer or DataURL\r\n  const fileData = await new Promise((resolve, reject) => {\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject(new Error(\"Failed to read file\"));\r\n    if (isImage) {\r\n      reader.readAsDataURL(file);\r\n    } else {\r\n      reader.readAsArrayBuffer(file);\r\n    }\r\n  });\r\n\r\n  try {\r\n    let bytes;\r\n\r\n    if (isImage) {\r\n      // QR decode: await the async image load/processing\r\n      const dataUrl = fileData;\r\n      bytes = await new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.crossOrigin = \"anonymous\";\r\n        img.onload = () => {\r\n          try {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n            const ctx = canvas.getContext(\"2d\");\r\n            ctx.drawImage(img, 0, 0);\r\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n            const info = jsQR(imageData.data, canvas.width, canvas.height);\r\n            if (!info?.data) {\r\n              reject(new Error(\"Invalid or missing QR code\"));\r\n              return;\r\n            }\r\n            resolve(info.data);\r\n          } catch (err) {\r\n            reject(new Error(\"Failed to process QR image: \" + err.message));\r\n          }\r\n        };\r\n        img.onerror = () => reject(new Error(\"Failed to load image\"));\r\n        img.src = dataUrl;\r\n      });\r\n\r\n      if (onText) onText(bytes);\r\n      if (onDataLoaded) onDataLoaded(base64ToUint8(bytes));\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n          name: file.name,\r\n          type: file.type,\r\n          size: formatBytes(file.size),\r\n        });\r\n      }\r\n      return { success: true };\r\n    } else {\r\n      // Non-image (.ec) branch\r\n      bytes = new Uint8Array(fileData);\r\n\r\n      if (bytes.length < 2 || bytes[0] !== 0xEC || bytes[1] !== 0x01) {\r\n        throw new Error(\"Invalid .ec file\");\r\n      }\r\n\r\n      const data = bytes.slice(2); // strip magic\r\n\r\n      if (onDataLoaded) onDataLoaded(data);\r\n      if (onBase64) onBase64(uint8ToBase64(data));\r\n      if (onText) {\r\n        let text;\r\n        try {\r\n          text = new TextDecoder().decode(data);\r\n        } catch {\r\n          text = \"[Unreadable binary data]\";\r\n        }\r\n        onText(text);\r\n      }\r\n      \r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n          name: file.name,\r\n          type: file.type || \"application/x-ec\",\r\n          size: formatBytes(file.size),\r\n        });\r\n      }\r\n      return { success: true };\r\n    }\r\n  } catch (err) {\r\n    return { error: \"Failed to process file: \" + (err?.message || \"unknown\") };\r\n  }\r\n}\r\n\r\n// returns file size\r\nexport function formatBytes(bytes) {\r\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\r\n  if (bytes === 0) return \"0 Bytes\";\r\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\r\n  return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + \" \" + sizes[i];\r\n}\r\n\r\n// Detects file type if no result returns txt\r\nexport async function detectFileExtension(bytes) {\r\n  // Check for .ec magic number 0xEC01 (first two bytes)\r\n  if (bytes.length >= 2 && bytes[0] === 0xEC && bytes[1] === 0x01) {\r\n    return \"ec\";\r\n  }\r\n\r\n  const hex = [...bytes.slice(0, 8)]\r\n    .map((b) => b.toString(16).padStart(2, \"0\"))\r\n    .join(\"\")\r\n    .toUpperCase();\r\n\r\n  if (hex.startsWith(\"504B0304\")) {\r\n    try {\r\n      const zip = await JSZip.loadAsync(bytes);\r\n      const fileNames = Object.keys(zip.files);\r\n\r\n      if (fileNames.some(name => name.startsWith(\"word/\"))) return \"docx\";\r\n      if (fileNames.some(name => name.startsWith(\"xl/\"))) return \"xlsx\";\r\n      if (fileNames.some(name => name.startsWith(\"ppt/\"))) return \"pptx\";\r\n      \r\n      return \"zip\";\r\n    } catch (e) {\r\n      return \"zip\";\r\n    }\r\n  }\r\n\r\n  // Known binary file signatures\r\n  if (hex.startsWith(\"89504E47\")) return \"png\";\r\n  if (hex.startsWith(\"FFD8FF\")) return \"jpg\";\r\n  if (hex.startsWith(\"25504446\")) return \"pdf\";\r\n  if (hex.startsWith(\"47494638\")) return \"gif\";\r\n  if (hex.includes(\"66747970\")) return \"mp4\";\r\n  if (hex.startsWith(\"52494646\")) return \"wav\";\r\n  if (hex.startsWith(\"000001BA\")) return \"mpg\";\r\n  \r\n  // Check for binary (non-printable control characters)\r\n  const isBinary = bytes.slice(0, 512).some(\r\n    (b) =>\r\n      b < 0x09 || (b > 0x0D && b < 0x20) || b > 0x7E\r\n  );\r\n\r\n  if (isBinary) return \"bin\";\r\n\r\n  // Otherwise, decode as normal text and guess\r\n  const text = new TextDecoder().decode(bytes.slice(0, 1024)).trim();\r\n\r\n  if (text.startsWith(\"{\") || text.startsWith(\"[\")) return \"json\";\r\n  if (text.includes(\",\") && text.match(/\\n|;/)) return \"csv\";\r\n\r\n  return \"txt\";\r\n}\r\n\r\n// random number for files\r\nfunction randomNumber(max = 9999) {\r\n    const date = Date.now().toString().slice(0, 6);\r\n    const rand = Math.floor(Math.random() * max);\r\n    return date + rand;\r\n}\r\n\r\nconst fileId = randomNumber();\r\n\r\n\r\n// saves as .ec file\r\nexport function saveFileAsEc(input, name) {\r\n    if (!name) name = \"\";\r\n    // Magic number (2 bytes): 0xEC01\r\n    const MAGIC_BYTES = new Uint8Array([0xEC, 0x01]);\r\n\r\n    const blob = new Blob([MAGIC_BYTES, input], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.ec`;\r\n    a.click();\r\n}\r\n\r\n\r\n// save file as ext\r\nexport async function saveFileAsExt(input, ext, name) {\r\n    if (!name) name = \"\";\r\n    const blob = new Blob([input], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.${ext}`;\r\n    a.click();\r\n}\r\n\r\n\r\nexport function downloadQrCode(canvas, name) {\r\n    if (!name) name = \"\";\r\n    if (!(canvas instanceof HTMLCanvasElement)) return { error: \"Invalid canvas element.\" };\r\n\r\n    const link = document.createElement('a');\r\n    link.href = canvas.toDataURL('image/png');\r\n    link.download = `${name}${fileId}.png`;\r\n    link.click();    \r\n}\r\n\r\n\r\nexport function saveFileAsEc32(input, name) {\r\n    if (!name) name = \"\";\r\n\r\n    // Magic number (1 element, 32-bit): 0xEC01\r\n    const MAGIC_UINT32 = new Uint32Array([0xEC01]);\r\n\r\n    // Combine header + data into one Uint32Array\r\n    const combined = new Uint32Array(MAGIC_UINT32.length + input.length);\r\n    combined.set(MAGIC_UINT32, 0);\r\n    combined.set(input, MAGIC_UINT32.length);\r\n\r\n    // Save as raw bytes\r\n    const blob = new Blob([combined.buffer], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.ec32`; // extension for clarity\r\n    a.click();\r\n}\r\n\r\n\r\n// Upload and parse a .ec32 file (Uint32Array format with 32-bit magic).\r\nexport async function uploadEncFile32(file, options = {}) {\r\n  const { onUint32, onInt32, onText, onTextInt, onFileInfo } = options;\r\n\r\n  const reader = new FileReader();\r\n  const fileData = await new Promise((resolve, reject) => {\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject(new Error(\"Failed to read file\"));\r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n\r\n  try {\r\n    const uint32 = new Uint32Array(fileData);\r\n    const int32 = new Int32Array(fileData);\r\n\r\n    if (uint32.length < 1 || uint32[0] !== 0xEC01) {\r\n      throw new Error(\"Invalid .ec32 file (missing magic number)\");\r\n    }\r\n    if (int32.length < 1 || int32[0] !== 0xEC01) {\r\n      throw new Error(\"Invalid .ec32 file (missing magic number)\");\r\n    }\r\n\r\n    const uintData = uint32.slice(1); // strip 32-bit magic\r\n    const intKey = int32.slice(1); // strip 32-bit magic\r\n\r\n    if (onUint32) onUint32(uintData);\r\n    if (onInt32) onInt32(intKey);\r\n\r\n    if (onText) {\r\n      let text;\r\n      try {\r\n        text = new TextDecoder().decode(new Uint8Array(uintData.buffer));\r\n      } catch {\r\n        text = \"[Unreadable binary data]\";\r\n      }\r\n      onText(text);\r\n    }\r\n\r\n    if (onTextInt) {\r\n      let text;\r\n      try {\r\n        text = Array.from(intKey).join(\",\");\r\n      } catch {\r\n        text = \"[Unreadable binary data]\";\r\n      }\r\n      onTextInt(text);\r\n    }\r\n\r\n    if (onFileInfo) {\r\n      onFileInfo({\r\n        name: file.name,\r\n        type: file.type || \"application/x-ec32\",\r\n        size: file.size,\r\n        ext: \".ec32\",\r\n      });\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (err) {\r\n    return { error: \"Failed to process file: \" + (err?.message || \"unknown\") };\r\n  }\r\n}","import { randomizerUint32, expandUint8, uint8ToUint32, uint32ToUint8, reduceUint8 } from '../utils/cryptoUtils';\r\nimport { detectFileExtension } from '../utils/fileUtils';\r\n/* eslint-env worker */\r\n/* eslint-disable no-restricted-globals */\r\n\r\nself.addEventListener(\"message\", async (e) => {\r\n  const { type, load } = e.data;\r\n\r\n  if (type === \"shuffle\") {\r\n    const { uint8, allChar } = load;\r\n    \r\n    if (!uint8) {\r\n      return self.postMessage({ type: \"error\", error: \"No input provided.\" });\r\n    }\r\n\r\n    try {\r\n        const expanded = expandUint8(uint8);\r\n        const uint32View = uint8ToUint32(expanded);\r\n\r\n        const { shuffled, key } = quantShuffle32(uint32View, allChar);\r\n      \r\n        self.postMessage({\r\n            type: \"done-shuffle\",\r\n            result: { shuffled, key },\r\n        });\r\n    } catch (err) {\r\n        self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n    }\r\n\r\n  } else if (type === \"unshuffle\") {\r\n    let { shuffled, key } = load;\r\n\r\n    try {\r\n        const unshuffled = quantUnshuffle32(shuffled, key);\r\n        const uint8 = uint32ToUint8(unshuffled);\r\n        const origin = reduceUint8(uint8);\r\n\r\n        const ext = await detectFileExtension(origin);\r\n\r\n        self.postMessage({\r\n            type: \"done-unshuffle\",\r\n            result: { origin, ext},\r\n        });\r\n    } catch (err) {\r\n        self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n    }\r\n  }\r\n});\r\n\r\n\r\n\r\n// Quantum shuffle function (Uint32Array)\r\nexport function quantShuffle32(input, allChar = false) {\r\n    const shuffled = new Uint32Array(input.length);\r\n    const key = new Int32Array(input.length);\r\n\r\n    for (let i = 0; i < input.length; i++) {\r\n        const rotation = randomizerUint32(allChar);\r\n        key[i] = rotation;\r\n        shuffled[i] = input[i] + rotation;\r\n    }\r\n\r\n    return { shuffled, key };\r\n}\r\n\r\n// Reverse shuffle\r\nexport function quantUnshuffle32(shuffled, key) {\r\n    const original = new Uint32Array(shuffled.length);\r\n\r\n    for (let i = 0; i < shuffled.length; i++) {\r\n        original[i] = shuffled[i] - key[i];\r\n    }\r\n\r\n    return original;\r\n}\r\n"],"names":["randomizerUint32","allChar","arguments","length","undefined","rand","Math","random","value","floor","max","Date","now","toString","slice","randomNumber","self","addEventListener","async","type","load","e","data","uint8","postMessage","error","expanded","frontLen","backLen","frontPad","Uint8Array","backPad","crypto","getRandomValues","combined","set","expandUint8","uint32View","lengthArray","Uint32Array","paddedLength","ceil","buffer","uint8ToUint32","shuffled","key","input","Int32Array","i","rotation","quantShuffle32","result","err","_err$message","message","String","unshuffled","original","quantUnshuffle32","origin","Error","reduceUint8","uint32","originalLength","DataView","getUint32","uint32ToUint8","ext","bytes","hex","map","b","padStart","join","toUpperCase","startsWith","zip","JSZip","fileNames","Object","keys","files","some","name","includes","text","TextDecoder","decode","trim","match","detectFileExtension","_err$message2"],"sourceRoot":""}