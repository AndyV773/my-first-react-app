{"version":3,"file":"static/js/337.38b41302.chunk.js","mappings":"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","sources":["utils/cryptoUtils.js","utils/fileUtils.js","workers/cryptoWorker.worker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import CryptoJS from \"crypto-js\";\r\nimport pako from \"pako\";\r\n\r\n// Salt utilities\r\nfunction generateSaltBytes(length = 16) {\r\n    const array = new Uint8Array(length);\r\n    crypto.getRandomValues(array);\r\n    return array;\r\n}\r\n\r\nexport function bytesToHex(array) {\r\n    return Array.from(array)\r\n        .map(b => b.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\n// PRNG based on seed string\r\nfunction mulberry32(seed) {\r\n    return function () {\r\n        seed |= 0;\r\n        seed = (seed + 0x6d2b79f5) | 0;\r\n        let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);\r\n        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\r\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n    };\r\n}\r\n\r\n// Shuffle/unshuffle using deterministic PRNG\r\nfunction seededShuffle(array, key, reverse = false) {\r\n    const prng = mulberry32(\r\n        [...key].reduce((a, c) => a + c.charCodeAt(0), 0)\r\n    );\r\n    const indices = Array.from(array.keys());\r\n    for (let i = indices.length - 1; i > 0; i--) {\r\n        const j = Math.floor(prng() * (i + 1));\r\n        [indices[i], indices[j]] = [indices[j], indices[i]];\r\n    }\r\n\r\n    const result = new Uint8Array(array.length);\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (!reverse) result[i] = array[indices[i]];\r\n        else result[indices[i]] = array[i];\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Performs a deterministic shuffle of input data using a key-derived seed.\r\n * A Mulberry32 PRNG is seeded with the key + salt combination to generate a reproducible permutation.\r\n * \r\n * Note: This is not cryptographic encryption but reversible obfuscation.\r\n * \r\n * @param {Uint8Array} array - The byte array to shuffle.\r\n * @param {string} key - The key used to seed the PRNG.\r\n * @param {boolean} reverse - If true, unshuffles the data.\r\n * @returns {Uint8Array} The shuffled (or unshuffled) result.\r\n */\r\nexport function mulberryShuffle(fileInput, key) {\r\n    if (!fileInput) {\r\n        return { error: \"Upload a file.\" };\r\n    }\r\n    if (!key || key.trim() === \"\") {\r\n        return { error: \"Enter a key.\" };\r\n    }\r\n\r\n    const saltBytes = generateSaltBytes();\r\n    const salt = bytesToHex(saltBytes);\r\n    const newKey = key + salt;\r\n\r\n    const shuffled = seededShuffle(fileInput, newKey);\r\n\r\n    // Append salt bytes to end of shuffled data\r\n    const combined = new Uint8Array(shuffled.length + saltBytes.length);\r\n    combined.set(shuffled);\r\n    combined.set(saltBytes, shuffled.length);\r\n\r\n    return { result: combined };\r\n}\r\n\r\nexport function mulberryUnshuffle(fileInput, key) {\r\n  if (!fileInput) {\r\n    return { error: \"Upload a file.\" };\r\n  }\r\n  if (!key || key.trim() === \"\") {\r\n    return { error: \"Enter a key.\" };\r\n  }\r\n\r\n  const SALT_LENGTH = 16;\r\n  if (fileInput.length <= SALT_LENGTH) {\r\n    return { error: \"Invalid file: too short.\" };\r\n  }\r\n\r\n  const dataLength = fileInput.length - SALT_LENGTH;\r\n  const output = fileInput.slice(0, dataLength);\r\n  const saltBytes = fileInput.slice(dataLength);\r\n  const saltHex = bytesToHex(saltBytes);\r\n  const newKey = key + saltHex;\r\n\r\n  const unshuffled = seededShuffle(output, newKey, true);\r\n\r\n  return { result: unshuffled };\r\n}\r\n\r\n\r\n/**\r\n * Encrypts a Uint8Array using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} inputBytes - The input data to encrypt.\r\n * @param {string} password - The password for encryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcEncrypt(inputBytes, password) {\r\n  if (!inputBytes) return { error: \"No file data provided.\" };\r\n  if (!password) return { error: \"Password is required for encryption.\" };\r\n\r\n  try {\r\n    const wordArray = CryptoJS.lib.WordArray.create(inputBytes);\r\n    const salt = CryptoJS.lib.WordArray.random(16);\r\n    const iv = CryptoJS.lib.WordArray.random(16);\r\n\r\n    const key = CryptoJS.PBKDF2(password, salt, {\r\n      keySize: 256 / 32,\r\n      iterations: 1000,\r\n    });\r\n\r\n    const encrypted = CryptoJS.AES.encrypt(wordArray, key, {\r\n      iv,\r\n      mode: CryptoJS.mode.CBC,\r\n      padding: CryptoJS.pad.Pkcs7,\r\n    });\r\n\r\n    // Combine salt + IV + ciphertext\r\n    const combined = CryptoJS.lib.WordArray.create(\r\n      salt.words.concat(iv.words).concat(encrypted.ciphertext.words),\r\n      salt.sigBytes + iv.sigBytes + encrypted.ciphertext.sigBytes\r\n    );\r\n\r\n    // Convert to Uint8Array\r\n    const resultBytes = new Uint8Array(combined.sigBytes);\r\n    for (let i = 0; i < combined.sigBytes; i++) {\r\n      resultBytes[i] = (combined.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n    }\r\n\r\n    return { result: resultBytes };\r\n  } catch (err) {\r\n    return { error: \"Encryption failed: \" + err.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Decrypts a Uint8Array encrypted using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} encryptedBytes - The encrypted input data.\r\n * @param {string} password - The password used for decryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcDecrypt(encryptedBytes, password) {\r\n  if (!password) return { error: \"Password is required for decryption.\" };\r\n  if (!encryptedBytes || encryptedBytes.length < 32) {\r\n    return { error: \"Invalid or incomplete encrypted data.\" };\r\n  }\r\n\r\n  try {\r\n    // Extract salt (16 bytes) and IV (16 bytes)\r\n    const salt = CryptoJS.lib.WordArray.create(encryptedBytes.slice(0, 16));\r\n    const iv = CryptoJS.lib.WordArray.create(encryptedBytes.slice(16, 32));\r\n    const ciphertextBytes = encryptedBytes.slice(32);\r\n    const ciphertextWords = CryptoJS.lib.WordArray.create(ciphertextBytes);\r\n\r\n    // Derive key using PBKDF2\r\n    const key = CryptoJS.PBKDF2(password, salt, {\r\n      keySize: 256 / 32,\r\n      iterations: 1000,\r\n    });\r\n\r\n    const decrypted = CryptoJS.AES.decrypt(\r\n      { ciphertext: ciphertextWords },\r\n      key,\r\n      { iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }\r\n    );\r\n\r\n    // Convert decrypted WordArray to Uint8Array\r\n    const resultBytes = new Uint8Array(decrypted.sigBytes);\r\n    for (let i = 0; i < decrypted.sigBytes; i++) {\r\n      resultBytes[i] = (decrypted.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n    }\r\n\r\n    return { result: resultBytes };\r\n  } catch (err) {\r\n    return { error: \"Decryption failed: \" + err.message };\r\n  }\r\n}\r\n\r\nexport function randomizer(allChar) {\r\n  const rand = Math.random() * Math.random(); // bias toward lower numbers\r\n  return allChar\r\n    ? Math.floor(rand * (0x10ffff + 1))\r\n    : Math.floor(rand * 800) + 1;\r\n}\r\n\r\nexport function uint8ToBase64(uint8) {\r\n  let binary = \"\";\r\n  const chunkSize = 0x8000; // Avoid call stack overflow\r\n  for (let i = 0; i < uint8.length; i += chunkSize) {\r\n    binary += String.fromCharCode(...uint8.subarray(i, i + chunkSize));\r\n  }\r\n  return btoa(binary);\r\n}\r\n\r\nexport function base64ToUint8(base64) {\r\n  const binary = atob(base64);\r\n  const len = binary.length;\r\n  const bytes = new Uint8Array(len);\r\n  for (let i = 0; i < len; i++) {\r\n    bytes[i] = binary.charCodeAt(i);\r\n  }\r\n  return bytes;\r\n}\r\n\r\n\r\n// text encoder helper\r\nexport function textEncoder(str) {\r\n  return new TextEncoder().encode(str);\r\n}\r\n\r\n// text decoder helper\r\nexport function textDecoder(str) {\r\n  return new TextDecoder().decode(str);\r\n}\r\n\r\n// pako compression helper\r\nexport function compress(input) {\r\n  return pako.deflate(input);\r\n}\r\n\r\n// pako decompression help\r\nexport function decompress(input) {\r\n  return pako.inflate(input);\r\n}\r\n\r\n// AES-GCM encrypt data with password, returns base64 string\r\nexport async function aesGcmEncrypt(data, password) {\r\n  const enc = new TextEncoder();\r\n  const salt = crypto.getRandomValues(new Uint8Array(16));\r\n  const iv = crypto.getRandomValues(new Uint8Array(12));\r\n  const keyMaterial = await crypto.subtle.importKey(\r\n    \"raw\",\r\n    enc.encode(password),\r\n    { name: \"PBKDF2\" },\r\n    false,\r\n    [\"deriveKey\"]\r\n  );\r\n  const key = await crypto.subtle.deriveKey(\r\n    {\r\n      name: \"PBKDF2\",\r\n      salt,\r\n      iterations: 100000,\r\n      hash: \"SHA-256\",\r\n    },\r\n    keyMaterial,\r\n    { name: \"AES-GCM\", length: 256 },\r\n    false,\r\n    [\"encrypt\"]\r\n  );\r\n\r\n  const dataBuffer = typeof data === \"string\" ? enc.encode(data) : data;\r\n  const encrypted = await crypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, dataBuffer);\r\n\r\n  // Combine salt + iv + encrypted\r\n  const combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);\r\n  combined.set(salt, 0);\r\n  combined.set(iv, salt.length);\r\n  combined.set(new Uint8Array(encrypted), salt.length + iv.length);\r\n\r\n  // Convert to base64\r\n  // const toBase64 = (bytes) => {\r\n  //   let binary = '';\r\n  //   for (let i = 0; i < bytes.length; i++) {\r\n  //     binary += String.fromCharCode(bytes[i]);\r\n  //   }\r\n  //   return btoa(binary);\r\n  // };\r\n\r\n  // return toBase64(combined);\r\n  return combined;\r\n}\r\n\r\n\r\n// AES gcm Decryption\r\nexport async function aesGcmDecrypt(base64, password) {\r\n  // const data = Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));\r\n  const data = base64;\r\n  const salt = data.slice(0, 16);\r\n  const iv = data.slice(16, 28);\r\n  const ciphertext = data.slice(28);\r\n  const enc = new TextEncoder();\r\n  const keyMaterial = await crypto.subtle.importKey(\"raw\", enc.encode(password), { name: \"PBKDF2\" }, false, [\"deriveKey\"]);\r\n  const key = await crypto.subtle.deriveKey(\r\n    { name: \"PBKDF2\", salt, iterations: 100000, hash: \"SHA-256\" },\r\n    keyMaterial,\r\n    { name: \"AES-GCM\", length: 256 },\r\n    false,\r\n    [\"decrypt\"]\r\n  );\r\n  const decrypted = await crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, key, ciphertext);\r\n  return new Uint8Array(decrypted); // raw bytes\r\n}\r\n\r\n","import { uint8ToBase64 } from './cryptoUtils';\r\nimport JSZip from \"jszip\";\r\nimport jsQR from 'jsqr';\r\n\r\n\r\n/**\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {function(Uint8Array): void} [options.onDataLoaded]\r\n * @param {function(string): void} [options.onBase64]\r\n * @param {function({name, type, size}): void} [options.onFileInfo]\r\n * @param {function(string): void} [options.onText]\r\n */\r\nexport function uploadFile(file, options = {}) {\r\n  const {\r\n    onDataLoaded,     // function(Uint8Array): void\r\n    onBase64,         // function(base64Str): void\r\n    onFileInfo,       // function({ name, type, size }): void\r\n    onText,           // function(utf8String): void\r\n  } = options;\r\n\r\n  const reader = new FileReader();\r\n\r\n  reader.onload = async (e) => {\r\n    try {\r\n      let bytes = new Uint8Array(e.target.result);\r\n\r\n      // Call optional hooks\r\n      if (onDataLoaded) onDataLoaded(bytes);\r\n      if (onBase64) onBase64(uint8ToBase64(bytes));\r\n\r\n      if (onText) {\r\n        try {\r\n            const text = new TextDecoder().decode(bytes);\r\n            onText(text);\r\n        } catch {\r\n            onText(\"[Unreadable binary data]\");\r\n        }\r\n      }\r\n\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n            name: file.name,\r\n            type: file.type || 'unknown',\r\n            size: formatBytes(file.size),\r\n        });\r\n      }\r\n    } catch (err) {\r\n      return { error: \"Failed to process file.\" + err.message };\r\n    }\r\n  };\r\n\r\n  reader.onerror = () => {\r\n    return { error: \"Failed to read file.\" };\r\n  };\r\n\r\n  reader.readAsArrayBuffer(file);\r\n}\r\n\r\n/**\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {function(Uint8Array): void} [options.onDataLoaded]\r\n * @param {function(string): void} [options.onBase64]\r\n * @param {function({name, type, size, ext?: string}): void} [options.onFileInfo]\r\n * @param {function(string): void} [options.onText]\r\n * @param {function(Error): void} [options.onError]\r\n */\r\nexport async function uploadEncFile(file, options = {}) {\r\n  const { onDataLoaded, onBase64, onFileInfo, onText } = options;\r\n\r\n  const isImage = file.type.startsWith(\"image/\");\r\n  const reader = new FileReader();\r\n\r\n  // Helper to read ArrayBuffer or DataURL\r\n  const fileData = await new Promise((resolve, reject) => {\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject(new Error(\"Failed to read file\"));\r\n    if (isImage) {\r\n      reader.readAsDataURL(file);\r\n    } else {\r\n      reader.readAsArrayBuffer(file);\r\n    }\r\n  });\r\n\r\n  try {\r\n    let bytes;\r\n\r\n    if (isImage) {\r\n      // QR decode: await the async image load/processing\r\n      const dataUrl = fileData;\r\n      bytes = await new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.crossOrigin = \"anonymous\";\r\n        img.onload = () => {\r\n          try {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n            const ctx = canvas.getContext(\"2d\");\r\n            ctx.drawImage(img, 0, 0);\r\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n            const info = jsQR(imageData.data, canvas.width, canvas.height);\r\n            if (!info?.data) {\r\n              reject(new Error(\"Invalid or missing QR code\"));\r\n              return;\r\n            }\r\n            resolve(info.data);\r\n          } catch (err) {\r\n            reject(new Error(\"Failed to process QR image: \" + err.message));\r\n          }\r\n        };\r\n        img.onerror = () => reject(new Error(\"Failed to load image\"));\r\n        img.src = dataUrl;\r\n      });\r\n\r\n      if (onText) onText(bytes);\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n          name: file.name,\r\n          type: file.type,\r\n          size: formatBytes(file.size),\r\n        });\r\n      }\r\n      return { success: true };\r\n    } else {\r\n      // Non-image (.ec) branch\r\n      bytes = new Uint8Array(fileData);\r\n\r\n      if (bytes.length < 2 || bytes[0] !== 0xEC || bytes[1] !== 0x01) {\r\n        throw new Error(\"Invalid .ec file\");\r\n      }\r\n\r\n      const data = bytes.slice(2); // strip magic\r\n\r\n      if (onDataLoaded) onDataLoaded(data);\r\n      if (onBase64) onBase64(uint8ToBase64(data));\r\n      if (onText) {\r\n        let text;\r\n        try {\r\n          text = new TextDecoder().decode(data);\r\n        } catch {\r\n          text = \"[Unreadable binary data]\";\r\n        }\r\n        onText(text);\r\n      }\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n          name: file.name,\r\n          type: file.type || \"application/x-ec\",\r\n          size: formatBytes(file.size),\r\n        });\r\n      }\r\n      return { success: true };\r\n    }\r\n  } catch (err) {\r\n    return { error: \"Failed to process file: \" + (err?.message || \"unknown\") };\r\n  }\r\n}\r\n\r\n\r\n\r\n// returns file size\r\nfunction formatBytes(bytes) {\r\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\r\n  if (bytes === 0) return \"0 Bytes\";\r\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\r\n  return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + \" \" + sizes[i];\r\n}\r\n\r\n// Detects file type if no result returns txt\r\nexport async function detectFileExtension(bytes) {\r\n  // Check for .ec magic number 0xEC01 (first two bytes)\r\n  if (bytes.length >= 2 && bytes[0] === 0xEC && bytes[1] === 0x01) {\r\n    return \"ec\";\r\n  }\r\n\r\n  const hex = [...bytes.slice(0, 8)]\r\n    .map((b) => b.toString(16).padStart(2, \"0\"))\r\n    .join(\"\")\r\n    .toUpperCase();\r\n\r\n  if (hex.startsWith(\"504B0304\")) {\r\n    try {\r\n      const zip = await JSZip.loadAsync(bytes);\r\n      const fileNames = Object.keys(zip.files);\r\n\r\n      if (fileNames.some(name => name.startsWith(\"word/\"))) return \"docx\";\r\n      if (fileNames.some(name => name.startsWith(\"xl/\"))) return \"xlsx\";\r\n      if (fileNames.some(name => name.startsWith(\"ppt/\"))) return \"pptx\";\r\n      \r\n      return \"zip\";\r\n    } catch (e) {\r\n      return \"zip\";\r\n    }\r\n  }\r\n\r\n  // Known binary file signatures\r\n  if (hex.startsWith(\"89504E47\")) return \"png\";\r\n  if (hex.startsWith(\"FFD8FF\")) return \"jpg\";\r\n  if (hex.startsWith(\"25504446\")) return \"pdf\";\r\n  if (hex.startsWith(\"47494638\")) return \"gif\";\r\n  if (hex.includes(\"66747970\")) return \"mp4\";\r\n  if (hex.startsWith(\"52494646\")) return \"wav\";\r\n  if (hex.startsWith(\"000001BA\")) return \"mpg\";\r\n  \r\n  // Check for binary (non-printable control characters)\r\n  const isBinary = bytes.slice(0, 512).some(\r\n    (b) =>\r\n      b < 0x09 || (b > 0x0D && b < 0x20) || b > 0x7E\r\n  );\r\n\r\n  if (isBinary) return \"bin\";\r\n\r\n  // Otherwise, decode as normal text and guess\r\n  const text = new TextDecoder().decode(bytes.slice(0, 1024)).trim();\r\n\r\n  if (text.startsWith(\"{\") || text.startsWith(\"[\")) return \"json\";\r\n  if (text.includes(\",\") && text.match(/\\n|;/)) return \"csv\";\r\n\r\n  return \"txt\";\r\n}\r\n\r\n// random number for files\r\nfunction randomNumber(max = 9999) {\r\n    const date = Date.now().toString().slice(0, 6);\r\n    const rand = Math.floor(Math.random() * max);\r\n    return date + rand;\r\n}\r\n\r\nconst fileId = randomNumber();\r\n\r\n\r\n// saves as .ec file\r\nexport function saveFileAsEc(input, name) {\r\n    if (!name) name = \"\";\r\n    // Magic number (2 bytes): 0xEC01\r\n    const MAGIC_BYTES = new Uint8Array([0xEC, 0x01]);\r\n\r\n    const blob = new Blob([MAGIC_BYTES, input], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.ec`;\r\n    a.click();\r\n}\r\n\r\n\r\n// save file as ext\r\nexport async function saveFileAsExt(input, ext, name) {\r\n    if (!name) name = \"\";\r\n    const blob = new Blob([input], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.${ext}`;\r\n    a.click();\r\n}\r\n\r\n\r\nexport function downloadQrCode(canvas, name) {\r\n    if (!name) name = \"\";\r\n    if (!(canvas instanceof HTMLCanvasElement)) return { error: \"Invalid canvas element.\" };\r\n\r\n    const link = document.createElement('a');\r\n    link.href = canvas.toDataURL('image/png');\r\n    link.download = `${name}${fileId}.png`;\r\n    link.click();    \r\n}","import { randomizer, uint8ToBase64, base64ToUint8 } from '../utils/cryptoUtils';\r\nimport { detectFileExtension } from '../utils/fileUtils';\r\n/* eslint-env worker */\r\n/* eslint-disable no-restricted-globals */\r\n\r\nself.addEventListener(\"message\", async (e) => {\r\n  const { type, payload } = e.data;\r\n\r\n  if (type === \"shuffle\") {\r\n    const { input, fileInput, allChar } = payload;\r\n\r\n    let rawInput = \"\";\r\n\r\n    if (fileInput) {\r\n      // Input is Uint8Array (from file read) â†’ base64 for shuffling\r\n      rawInput = uint8ToBase64(input);\r\n    } else {\r\n      const text = input; // plain text input\r\n      if (!text) {\r\n        return self.postMessage({ type: \"error\", error: \"No input provided.\" });\r\n      }\r\n      rawInput = text;\r\n    }\r\n\r\n    try {\r\n      const { shuffled, key } = quantShuffle(rawInput, allChar);\r\n      self.postMessage({\r\n        type: \"done-shuffle\",\r\n        result: { shuffled, key },\r\n      });\r\n    } catch (err) {\r\n      self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n    }\r\n\r\n  } else if (type === \"unshuffle\") {\r\n    const { shuffled, key } = payload;\r\n\r\n    try {\r\n      const unshuffled = await quantUnshuffle(shuffled, key);\r\n      let output, ext;\r\n\r\n      try {\r\n        const bytes = base64ToUint8(unshuffled);\r\n        ext = await detectFileExtension(bytes);\r\n\r\n        if (ext !== \"bin\") {\r\n          output = base64ToUint8(unshuffled);\r\n        } else {\r\n          output = unshuffled;\r\n        }\r\n\r\n      } catch (err) {\r\n        output = unshuffled;\r\n        ext = \"txt\";\r\n      }\r\n\r\n      self.postMessage({\r\n        type: \"done-unshuffle\",\r\n        result: { output, ext},\r\n      });\r\n    } catch (err) {\r\n      self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n    }\r\n  }\r\n});\r\n\r\nfunction quantShuffle(input, allChar = false) {\r\n  const data = { shuffled: \"\", key: [] };\r\n\r\n  for (let i = 0; i < input.length; i++) {\r\n    const char = input[i];\r\n    const codePoint = char.codePointAt(0);\r\n  \r\n    let rotation, shuffledData;\r\n\r\n    do {\r\n      rotation = randomizer(allChar);\r\n      shuffledData = codePoint + rotation;\r\n    } while (\r\n      shuffledData > 0x10ffff ||\r\n      shuffledData < 0 ||\r\n      (shuffledData >= 0xd800 && shuffledData <= 0xdfff)\r\n    );\r\n\r\n    data.shuffled += String.fromCodePoint(shuffledData);\r\n    data.key.push(rotation);\r\n  }\r\n\r\n  data.key = data.key.join(\",\");\r\n\r\n  return {\r\n    shuffled: data.shuffled,\r\n    key: data.key, // will be turned into Uint32Array by caller\r\n  };\r\n}\r\n\r\n\r\n// takes data and key and returns undhuffled data\r\nasync function quantUnshuffle(inputData, inputKey) {\r\n  const key = inputKey.split(\",\").map(Number);\r\n  let decodedString = \"\";\r\n  let i = 0;\r\n  \r\n  for (const char of inputData) {\r\n    let shuffledData = char.codePointAt(0);\r\n    let rotations = key[i++] ?? 0;\r\n    let output = (shuffledData - rotations + 0x10ffff) % 0x10ffff;\r\n    decodedString += String.fromCodePoint(output);\r\n  }\r\n\r\n  return decodedString;\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [128], () => (__webpack_require__(7594)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"ac6b67ca\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/my-first-react-app/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t337: 1,\n\t718: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkencryption_toolkit\"] = self[\"webpackChunkencryption_toolkit\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(128).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["randomizer","allChar","rand","Math","random","floor","base64ToUint8","base64","binary","atob","len","length","bytes","Uint8Array","i","charCodeAt","max","arguments","undefined","Date","now","toString","slice","randomNumber","self","addEventListener","async","type","payload","e","data","input","fileInput","rawInput","uint8","String","fromCharCode","subarray","btoa","uint8ToBase64","text","postMessage","error","shuffled","key","codePoint","codePointAt","rotation","shuffledData","fromCodePoint","push","join","quantShuffle","result","err","_err$message","message","unshuffled","inputData","inputKey","split","map","Number","decodedString","char","_key$i","output","quantUnshuffle","ext","hex","b","padStart","toUpperCase","startsWith","zip","JSZip","fileNames","Object","keys","files","some","name","includes","TextDecoder","decode","trim","match","detectFileExtension","_err$message2","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}