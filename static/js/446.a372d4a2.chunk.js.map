{"version":3,"file":"static/js/446.a372d4a2.chunk.js","mappings":"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","sources":["utils/cryptoUtils.js","workers/cryptoWorker.worker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import CryptoJS from \"crypto-js\";\r\nimport pako from \"pako\";\r\n\r\n// Salt utilities\r\nfunction generateSaltBytes(length = 16) {\r\n    const array = new Uint8Array(length);\r\n    crypto.getRandomValues(array);\r\n    return array;\r\n}\r\n\r\nfunction bytesToHex(array) {\r\n    return Array.from(array)\r\n        .map(b => b.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\n// PRNG based on seed string\r\nfunction mulberry32(seed) {\r\n    return function () {\r\n        seed |= 0;\r\n        seed = (seed + 0x6d2b79f5) | 0;\r\n        let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);\r\n        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\r\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n    };\r\n}\r\n\r\n// Shuffle/unshuffle using deterministic PRNG\r\nfunction seededShuffle(array, key, reverse = false) {\r\n    const prng = mulberry32(\r\n        [...key].reduce((a, c) => a + c.charCodeAt(0), 0)\r\n    );\r\n    const indices = Array.from(array.keys());\r\n    for (let i = indices.length - 1; i > 0; i--) {\r\n        const j = Math.floor(prng() * (i + 1));\r\n        [indices[i], indices[j]] = [indices[j], indices[i]];\r\n    }\r\n\r\n    const result = new Uint8Array(array.length);\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (!reverse) result[i] = array[indices[i]];\r\n        else result[indices[i]] = array[i];\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Performs a deterministic shuffle of input data using a key-derived seed.\r\n * A Mulberry32 PRNG is seeded with the key + salt combination to generate a reproducible permutation.\r\n * \r\n * Note: This is not cryptographic encryption but reversible obfuscation.\r\n * \r\n * @param {Uint8Array} array - The byte array to shuffle.\r\n * @param {string} key - The key used to seed the PRNG.\r\n * @param {boolean} reverse - If true, unshuffles the data.\r\n * @returns {Uint8Array} The shuffled (or unshuffled) result.\r\n */\r\nexport function mulberryShuffle(fileInput, key) {\r\n    if (!fileInput) {\r\n        return { error: \"Upload a file.\" };\r\n    }\r\n    if (!key || key.trim() === \"\") {\r\n        return { error: \"Enter a key.\" };\r\n    }\r\n\r\n    const saltBytes = generateSaltBytes();\r\n    const salt = bytesToHex(saltBytes);\r\n    const newKey = key + salt;\r\n\r\n    const shuffled = seededShuffle(fileInput, newKey);\r\n\r\n    // Append salt bytes to end of shuffled data\r\n    const combined = new Uint8Array(shuffled.length + saltBytes.length);\r\n    combined.set(shuffled);\r\n    combined.set(saltBytes, shuffled.length);\r\n\r\n    return { result: combined };\r\n}\r\n\r\nexport function mulberryUnshuffle(fileInput, key) {\r\n  if (!fileInput) {\r\n    return { error: \"Upload a file.\" };\r\n  }\r\n  if (!key || key.trim() === \"\") {\r\n    return { error: \"Enter a key.\" };\r\n  }\r\n\r\n  const SALT_LENGTH = 16;\r\n  if (fileInput.length <= SALT_LENGTH) {\r\n    return { error: \"Invalid file: too short.\" };\r\n  }\r\n\r\n  const dataLength = fileInput.length - SALT_LENGTH;\r\n  const output = fileInput.slice(0, dataLength);\r\n  const saltBytes = fileInput.slice(dataLength);\r\n  const saltHex = bytesToHex(saltBytes);\r\n  const newKey = key + saltHex;\r\n\r\n  const unshuffled = seededShuffle(output, newKey, true);\r\n\r\n  return { result: unshuffled };\r\n}\r\n\r\n\r\n/**\r\n * Encrypts a Uint8Array using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} inputBytes - The input data to encrypt.\r\n * @param {string} password - The password for encryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcEncrypt(inputBytes, password) {\r\n  if (!inputBytes) return { error: \"No file data provided.\" };\r\n  if (!password) return { error: \"Password is required for encryption.\" };\r\n\r\n  try {\r\n    const wordArray = CryptoJS.lib.WordArray.create(inputBytes);\r\n    const salt = CryptoJS.lib.WordArray.random(16);\r\n    const iv = CryptoJS.lib.WordArray.random(16);\r\n\r\n    const key = CryptoJS.PBKDF2(password, salt, {\r\n      keySize: 256 / 32,\r\n      iterations: 1000,\r\n    });\r\n\r\n    const encrypted = CryptoJS.AES.encrypt(wordArray, key, {\r\n      iv,\r\n      mode: CryptoJS.mode.CBC,\r\n      padding: CryptoJS.pad.Pkcs7,\r\n    });\r\n\r\n    // Combine salt + IV + ciphertext\r\n    const combined = CryptoJS.lib.WordArray.create(\r\n      salt.words.concat(iv.words).concat(encrypted.ciphertext.words),\r\n      salt.sigBytes + iv.sigBytes + encrypted.ciphertext.sigBytes\r\n    );\r\n\r\n    // Convert to Uint8Array\r\n    const resultBytes = new Uint8Array(combined.sigBytes);\r\n    for (let i = 0; i < combined.sigBytes; i++) {\r\n      resultBytes[i] = (combined.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n    }\r\n\r\n    return { result: resultBytes };\r\n  } catch (err) {\r\n    return { error: \"Encryption failed: \" + err.message };\r\n  }\r\n}\r\n\r\n/**\r\n * Decrypts a Uint8Array encrypted using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} encryptedBytes - The encrypted input data.\r\n * @param {string} password - The password used for decryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcDecrypt(encryptedBytes, password) {\r\n  if (!password) return { error: \"Password is required for decryption.\" };\r\n  if (!encryptedBytes || encryptedBytes.length < 32) {\r\n    return { error: \"Invalid or incomplete encrypted data.\" };\r\n  }\r\n\r\n  try {\r\n    // Extract salt (16 bytes) and IV (16 bytes)\r\n    const salt = CryptoJS.lib.WordArray.create(encryptedBytes.slice(0, 16));\r\n    const iv = CryptoJS.lib.WordArray.create(encryptedBytes.slice(16, 32));\r\n    const ciphertextBytes = encryptedBytes.slice(32);\r\n    const ciphertextWords = CryptoJS.lib.WordArray.create(ciphertextBytes);\r\n\r\n    // Derive key using PBKDF2\r\n    const key = CryptoJS.PBKDF2(password, salt, {\r\n      keySize: 256 / 32,\r\n      iterations: 1000,\r\n    });\r\n\r\n    const decrypted = CryptoJS.AES.decrypt(\r\n      { ciphertext: ciphertextWords },\r\n      key,\r\n      { iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }\r\n    );\r\n\r\n    // Convert decrypted WordArray to Uint8Array\r\n    const resultBytes = new Uint8Array(decrypted.sigBytes);\r\n    for (let i = 0; i < decrypted.sigBytes; i++) {\r\n      resultBytes[i] = (decrypted.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n    }\r\n\r\n    return { result: resultBytes };\r\n  } catch (err) {\r\n    return { error: \"Decryption failed: \" + err.message };\r\n  }\r\n}\r\n\r\nexport function randomizer(allChar) {\r\n  const rand = Math.random() * Math.random(); // bias toward lower numbers\r\n  return allChar\r\n    ? Math.floor(rand * (0x10ffff + 1))\r\n    : Math.floor(rand * 800) + 1;\r\n}\r\n\r\nexport function uint8ToBase64(uint8) {\r\n  let binary = \"\";\r\n  for (let i = 0; i < uint8.length; i++) {\r\n    binary += String.fromCharCode(uint8[i]);\r\n  }\r\n  return btoa(binary);\r\n}\r\n\r\n// pako compression helper\r\nexport function compress(input) {\r\n  return pako.deflate(input);\r\n}\r\n\r\n// AES-GCM encrypt data with password, returns base64 string\r\nexport async function aesGcmEncrypt(data, password) {\r\n  const enc = new TextEncoder();\r\n  const salt = crypto.getRandomValues(new Uint8Array(16));\r\n  const iv = crypto.getRandomValues(new Uint8Array(12));\r\n  const keyMaterial = await crypto.subtle.importKey(\r\n    \"raw\",\r\n    enc.encode(password),\r\n    { name: \"PBKDF2\" },\r\n    false,\r\n    [\"deriveKey\"]\r\n  );\r\n  const key = await crypto.subtle.deriveKey(\r\n    {\r\n      name: \"PBKDF2\",\r\n      salt,\r\n      iterations: 100000,\r\n      hash: \"SHA-256\",\r\n    },\r\n    keyMaterial,\r\n    { name: \"AES-GCM\", length: 256 },\r\n    false,\r\n    [\"encrypt\"]\r\n  );\r\n\r\n  const dataBuffer = typeof data === \"string\" ? enc.encode(data) : data;\r\n  const encrypted = await crypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, dataBuffer);\r\n\r\n  // Combine salt + iv + encrypted\r\n  const combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);\r\n  combined.set(salt, 0);\r\n  combined.set(iv, salt.length);\r\n  combined.set(new Uint8Array(encrypted), salt.length + iv.length);\r\n\r\n  // Convert to base64\r\n  const toBase64 = (bytes) => {\r\n    let binary = '';\r\n    for (let i = 0; i < bytes.length; i++) {\r\n      binary += String.fromCharCode(bytes[i]);\r\n    }\r\n    return btoa(binary);\r\n  };\r\n\r\n  return toBase64(combined);\r\n}\r\n\r\n\r\n","import { randomizer, uint8ToBase64 } from '../utils/cryptoUtils';\r\n/* eslint-env worker */\r\n/* eslint-disable no-restricted-globals */\r\n\r\nself.addEventListener(\"message\", (e) => {\r\n  const { type, payload } = e.data;\r\n  if (type !== \"shuffle\") return;\r\n\r\n  const { input, fileInput, allChar } = payload;\r\n\r\n  let rawInput = \"\";\r\n\r\n  if (fileInput) {\r\n    // Input is Uint8Array (from file read)\r\n    rawInput = uint8ToBase64(input); \r\n  } else {\r\n    const text = input;  // plain text input\r\n    if (!text) return self.postMessage({ type: \"error\", error: \"No input provided.\"});\r\n    rawInput = text;\r\n  }\r\n\r\n  try {\r\n    const { shuffled, key } = quantShuffle(rawInput, allChar);\r\n    self.postMessage({\r\n      type: \"done\",\r\n      result: { shuffled, key },\r\n    });\r\n  } catch (err) {\r\n    self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n  }\r\n});\r\n\r\nfunction quantShuffle(input, allChar = false) {\r\n  const data = { shuffled: \"\", key: [] };\r\n\r\n  for (let i = 0; i < input.length; i++) {\r\n    const char = input[i];\r\n    const codePoint = char.codePointAt(0);\r\n  \r\n    let rotation, shuffledData;\r\n\r\n    do {\r\n      rotation = randomizer(allChar);\r\n      shuffledData = codePoint + rotation;\r\n    } while (\r\n      shuffledData > 0x10ffff ||\r\n      shuffledData < 0 ||\r\n      (shuffledData >= 0xd800 && shuffledData <= 0xdfff)\r\n    );\r\n\r\n    data.shuffled += String.fromCodePoint(shuffledData);\r\n    data.key.push(rotation);\r\n  }\r\n\r\n  data.key = data.key.join(\",\");\r\n\r\n  return {\r\n    shuffled: data.shuffled,\r\n    key: data.key, // will be turned into Uint32Array by caller\r\n  };\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [342], () => (__webpack_require__(6589)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"a10526d5\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/my-first-react-app/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t446: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkencryption_toolkit\"] = self[\"webpackChunkencryption_toolkit\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(342).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["randomizer","allChar","rand","Math","random","floor","self","addEventListener","e","type","payload","data","input","fileInput","rawInput","uint8","binary","i","length","String","fromCharCode","btoa","uint8ToBase64","text","postMessage","error","shuffled","key","arguments","undefined","codePoint","codePointAt","rotation","shuffledData","fromCodePoint","push","join","quantShuffle","result","err","_err$message","message","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","every","splice","r","d","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}