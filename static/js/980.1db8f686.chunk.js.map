{"version":3,"file":"static/js/980.1db8f686.chunk.js","mappings":"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","sources":["utils/cryptoUtils.js","utils/fileUtils.js","workers/cryptoWorkerUnit32.worker.js"],"sourcesContent":["import CryptoJS from \"crypto-js\";\r\nimport pako from \"pako\";\r\n\r\n\r\n// text encoder helper\r\nexport function textEncoder(input) {\r\n  \treturn new TextEncoder().encode(input);\r\n}\r\n\r\n\r\n// text decoder helper\r\nexport function textDecoder(input) {\r\n  \treturn new TextDecoder().decode(input);\r\n}\r\n\r\n\r\n// pako compression helper\r\nexport function compress(input) {\r\n  \treturn pako.deflate(input);\r\n}\r\n\r\n\r\n// pako decompression help\r\nexport function decompress(input) {\r\n  \treturn pako.inflate(input);\r\n}\r\n\r\n\r\nexport const sha256 = async (data) => {\r\n\tconst buffer = await crypto.subtle.digest(\"SHA-256\", data);\r\n\treturn Array.from(new Uint8Array(buffer))\r\n\t\t.map((b) => b.toString(16).padStart(2, \"0\"))\r\n\t\t.join(\"\");\r\n};\r\n\r\n\r\n// Salt utilities\r\nexport function generateSaltBytes(length = 16) {\r\n    const array = new Uint8Array(length);\r\n    window.crypto.getRandomValues(array);\r\n    return array;\r\n}\r\n\r\n\r\nexport function bytesToHex(array) {\r\n    return Array.from(array)\r\n        .map(b => b.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\n\r\n// Convert a hexadecimal string (e.g., from SHA-256) into a byte array\r\nfunction hexToBytes(hex) {\r\n    const bytes = new Uint8Array(hex.length / 2);\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        // Parse each pair of hex digits into a byte\r\n        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);\r\n    }\r\n    return bytes;\r\n}\r\n\r\n\r\n// convert uint8 to base64 in chunks to avoid call stack\r\nexport function uint8ToBase64(uint8) {\r\n\tlet binary = \"\";\r\n\tconst chunkSize = 0x8000; // Avoid call stack overflow\r\n\tfor (let i = 0; i < uint8.length; i += chunkSize) {\r\n\t\tbinary += String.fromCharCode(...uint8.subarray(i, i + chunkSize));\r\n\t}\r\n\treturn btoa(binary);\r\n}\r\n\r\n\r\nexport function base64ToUint8(base64) {\r\n\tconst binary = atob(base64);\r\n\tconst len = binary.length;\r\n\tconst bytes = new Uint8Array(len);\r\n\tfor (let i = 0; i < len; i++) {\r\n\t\tbytes[i] = binary.charCodeAt(i);\r\n\t}\r\n\treturn bytes;\r\n}\r\n\r\n\r\n/**\r\n * Convert Uint8Array → Uint32Array, storing original length at the start\r\n */\r\nexport function uint8ToUint32(bytes) {\r\n    const paddedLength = Math.ceil(bytes.length / 4) * 4;\r\n    const padded = new Uint8Array(paddedLength);\r\n    padded.set(bytes);\r\n\r\n    const uint32Array = new Uint32Array(paddedLength / 4 + 1); // +1 for length\r\n    uint32Array[0] = bytes.length; // store original length\r\n\t\r\n    for (let i = 0; i < paddedLength / 4; i++) {\r\n        uint32Array[i + 1] =\r\n            (padded[i * 4] << 24) |\r\n            (padded[i * 4 + 1] << 16) |\r\n            (padded[i * 4 + 2] << 8) |\r\n            (padded[i * 4 + 3]);\r\n    }\r\n\r\n    return uint32Array;\r\n}\r\n\r\n\r\n/**\r\n * Convert Uint32Array → Uint8Array, using stored length to strip padding\r\n */\r\nexport function uint32ToUint8(input) {\r\n    // normalize input to Uint32Array\r\n    let uint32Array;\r\n    if (input instanceof Uint32Array) {\r\n        uint32Array = input;\r\n    } else if (Array.isArray(input)) {\r\n        uint32Array = new Uint32Array(input);\r\n    } else if (typeof input === \"string\") {\r\n        const parts = input.split(\",\").map(n => parseInt(n.trim(), 10));\r\n        if (parts.some(isNaN)) return \"Error: Invalid Uint32 input.\"; \r\n        uint32Array = new Uint32Array(parts);\r\n    } else {\r\n        return \"Error: Invalid Uint32 input.\";\r\n    }\r\n\r\n\tif (uint32Array.length < 1) return new Uint8Array();\r\n\r\n\tconst originalLength = uint32Array[0]; // first element is original length\r\n    const bytes = new Uint8Array((uint32Array.length - 1) * 4);\r\n\r\n    for (let i = 0; i < uint32Array.length; i++) {\r\n        const val = uint32Array[i];\r\n        const offset = (i - 1) * 4;\r\n        bytes[offset]     = (val >>> 24) & 0xFF;\r\n        bytes[offset + 1] = (val >>> 16) & 0xFF;\r\n        bytes[offset + 2] = (val >>> 8)  & 0xFF;\r\n        bytes[offset + 3] = val & 0xFF;\r\n    } \r\n\r\n    return bytes.subarray(0, originalLength);\r\n}\r\n\r\n\r\n// PRNG based on seed string\r\nfunction mulberry32(seed) {\r\n    return function () {\r\n        seed |= 0;\r\n        seed = (seed + 0x6d2b79f5) | 0;\r\n        let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);\r\n        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\r\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n    };\r\n}\r\n\r\n\r\n// Shuffle/unshuffle using deterministic PRNG\r\n// Fisher-Yates shuffle algorithm\r\nfunction seededShuffle(array, key, reverse = false) {\r\n    const prng = mulberry32(\r\n        [...key].reduce((a, c) => a + c.charCodeAt(0), 0)\r\n    );\r\n    const indices = Array.from(array.keys());\r\n    for (let i = indices.length - 1; i > 0; i--) {\r\n        const j = Math.floor(prng() * (i + 1));\r\n        [indices[i], indices[j]] = [indices[j], indices[i]];\r\n    }\r\n\r\n    const result = new Uint8Array(array.length);\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (!reverse) result[i] = array[indices[i]];\r\n        else result[indices[i]] = array[i];\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\n/**\r\n * Performs a deterministic shuffle of input data using a key-derived seed.\r\n * A Mulberry32 PRNG is seeded with the key + salt combination to generate a reproducible permutation.\r\n * \r\n * Note: This is not cryptographic encryption but reversible obfuscation.\r\n * \r\n * @param {Uint8Array} array - The byte array to shuffle.\r\n * @param {string} key - The key used to seed the PRNG.\r\n * @param {boolean} reverse - If true, unshuffles the data.\r\n * @returns {Uint8Array} The shuffled (or unshuffled) result.\r\n */\r\nexport function fishersShuffle(input, key) {\r\n    if (!input) {\r\n        return { error: \"Input data.\" };\r\n    }\r\n    if (!key || key.trim() === \"\") {\r\n        return { error: \"Enter a key.\" };\r\n    }\r\n\r\n    const saltBytesKey = generateSaltBytes();\r\n    const saltBytesInput = generateSaltBytes();\r\n    const salt = bytesToHex(saltBytesKey);\r\n    const newKey = key + salt;\r\n\r\n    const newInput = new Uint8Array(input.length + saltBytesInput.length);\r\n    newInput.set(saltBytesInput, 0);                 \r\n    newInput.set(input, saltBytesInput.length); \r\n\r\n    const shuffled = seededShuffle(newInput, newKey);\r\n\r\n    // Append salt bytes to end of shuffled data\r\n    const combined = new Uint8Array(shuffled.length + saltBytesKey.length);\r\n    combined.set(shuffled);\r\n    combined.set(saltBytesKey, shuffled.length);\r\n\r\n    return { result: combined };\r\n}\r\n\r\n\r\nexport function fishersUnshuffle(fileInput, key) {\r\n\tif (!fileInput) {\r\n\t\treturn { error: \"Upload a file.\" };\r\n\t}\r\n\tif (!key || key.trim() === \"\") {\r\n\t\treturn { error: \"Enter a key.\" };\r\n\t}\r\n\r\n\tconst SALT_LENGTH = 16;\r\n\tif (fileInput.length <= SALT_LENGTH) {\r\n\t\treturn { error: \"Invalid file: too short.\" };\r\n\t}\r\n\r\n\tconst dataLength = fileInput.length - SALT_LENGTH;\r\n\tconst output = fileInput.slice(0, dataLength);\r\n\tconst saltBytes = fileInput.slice(dataLength);\r\n\tconst saltHex = bytesToHex(saltBytes);\r\n\tconst newKey = key + saltHex;\r\n\r\n\tconst unshuffled = seededShuffle(output, newKey, true);\r\n\r\n\tconst trimmed = unshuffled.slice(16);\r\n\r\n\treturn { result: trimmed };\r\n}\r\n\r\n\r\n/**\r\n * Encrypts a Uint8Array using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} inputBytes - The input data to encrypt.\r\n * @param {string} password - The password for encryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcEncrypt(inputBytes, password) {\r\n\tif (!inputBytes) return { error: \"No file data provided.\" };\r\n\tif (!password) return { error: \"Password is required for encryption.\" };\r\n\r\n\ttry {\r\n\t\tconst wordArray = CryptoJS.lib.WordArray.create(inputBytes);\r\n\t\tconst salt = CryptoJS.lib.WordArray.random(16);\r\n\t\tconst iv = CryptoJS.lib.WordArray.random(16);\r\n\r\n\t\tconst key = CryptoJS.PBKDF2(password, salt, {\r\n\t\tkeySize: 256 / 32,\r\n\t\titerations: 1000,\r\n\t\t});\r\n\r\n\t\tconst encrypted = CryptoJS.AES.encrypt(wordArray, key, {\r\n\t\tiv,\r\n\t\tmode: CryptoJS.mode.CBC,\r\n\t\tpadding: CryptoJS.pad.Pkcs7,\r\n\t\t});\r\n\r\n\t\t// Combine salt + IV + ciphertext\r\n\t\tconst combined = CryptoJS.lib.WordArray.create(\r\n\t\tsalt.words.concat(iv.words).concat(encrypted.ciphertext.words),\r\n\t\tsalt.sigBytes + iv.sigBytes + encrypted.ciphertext.sigBytes\r\n\t\t);\r\n\r\n\t\t// Convert to Uint8Array\r\n\t\tconst resultBytes = new Uint8Array(combined.sigBytes);\r\n\t\tfor (let i = 0; i < combined.sigBytes; i++) {\r\n\t\tresultBytes[i] = (combined.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n\t\t}\r\n\r\n\t\treturn { result: resultBytes };\r\n\t} catch (err) {\r\n\t\treturn { error: \"Encryption failed: \" + err.message };\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Decrypts a Uint8Array encrypted using AES-CBC with a password-derived key.\r\n *\r\n * @param {Uint8Array} encryptedBytes - The encrypted input data.\r\n * @param {string} password - The password used for decryption.\r\n * @returns {{ error?: string, result?: Uint8Array }} Result object.\r\n */\r\nexport function aesCbcDecrypt(encryptedBytes, password) {\r\n\tif (!password) return { error: \"Password is required for decryption.\" };\r\n\tif (!encryptedBytes || encryptedBytes.length < 32) {\r\n\t\treturn { error: \"Invalid or incomplete encrypted data.\" };\r\n\t}\r\n\r\n\ttry {\r\n\t\t// Extract salt (16 bytes) and IV (16 bytes)\r\n\t\tconst salt = CryptoJS.lib.WordArray.create(encryptedBytes.slice(0, 16));\r\n\t\tconst iv = CryptoJS.lib.WordArray.create(encryptedBytes.slice(16, 32));\r\n\t\tconst ciphertextBytes = encryptedBytes.slice(32);\r\n\t\tconst ciphertextWords = CryptoJS.lib.WordArray.create(ciphertextBytes);\r\n\r\n\t\t// Derive key using PBKDF2\r\n\t\tconst key = CryptoJS.PBKDF2(password, salt, {\r\n\t\tkeySize: 256 / 32,\r\n\t\titerations: 1000,\r\n\t\t});\r\n\r\n\t\tconst decrypted = CryptoJS.AES.decrypt(\r\n\t\t{ ciphertext: ciphertextWords },\r\n\t\tkey,\r\n\t\t{ iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }\r\n\t\t);\r\n\r\n\t\t// Convert decrypted WordArray to Uint8Array\r\n\t\tconst resultBytes = new Uint8Array(decrypted.sigBytes);\r\n\t\tfor (let i = 0; i < decrypted.sigBytes; i++) {\r\n\t\tresultBytes[i] = (decrypted.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\r\n\t\t}\r\n\r\n\t\treturn { result: resultBytes };\r\n\t} catch (err) {\r\n\t\treturn { error: \"Decryption failed: \" + err.message };\r\n\t}\r\n}\r\n\r\n\r\n// export function randomizer(allChar) {\r\n//     const rand = Math.random() * Math.random(); // bias toward lower numbers\r\n\r\n//     let value = allChar\r\n//         ? Math.floor(rand * (0x10ffff + 1))\r\n//         : Math.floor(rand * 10000) + 1;\r\n\r\n//     // allow negative by randomly flipping sign\r\n//     if (Math.random() < 0.5) value = -value;\r\n\r\n//     return value;\r\n// }\r\n\r\n// Random rotation generator fo uint32\r\n// export function randomizerUint32(allChar = false) {\r\n// \tconst rand = Math.random() * Math.random(); // bias toward lower numbers\r\n// \tlet value = allChar\r\n// \t\t? Math.floor(rand * 4294967295) // full 32-bit range\r\n// \t\t: Math.floor(rand * 1000000) - 1000000; \r\n// \tif (Math.random() < 0.5) value = -value; // allow negative\r\n// \treturn value;\r\n// }\r\n\r\n\r\nexport function randomizer(allChar, uint32 = false) {\r\n\t// Helper to generate a random 32-bit unsigned integer\r\n\tconst randUint32 = () => {\r\n\t\tconst arr = new Uint32Array(1);\r\n\t\tcrypto.getRandomValues(arr);\r\n\t\treturn arr[0];\r\n\t};\r\n\r\n\tlet value;\r\n\r\n\tif (uint32) {\r\n\t\tif (allChar) {\r\n\t\t\t// Full 32-bit range: 0 to 0xFFFFFFFF\r\n\t\t\tvalue = randUint32();\r\n\t\t} else {\r\n\t\t\t// Range: 0 to 999,999\r\n\t\t\tvalue = randUint32() % 1_000_000;\r\n\t\t}\r\n\t\t// Randomly flip sign\r\n\t\tconst flipSign = (crypto.getRandomValues(new Uint8Array(1))[0] % 2) === 0;\r\n\t\tif (flipSign) value = -value;\r\n\r\n\t} else {\r\n\t\tif (allChar) {\r\n\t\t\t// Full Unicode range between 0 and 0x10FFFF\r\n\t\t\tvalue = randUint32() % (0x10FFFF + 1);\r\n\t\t} else {\r\n\t\t\t// range between 1 and 10000\r\n\t\t\tvalue = (randUint32() % 10000) + 1;\r\n\t\t}\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\n\r\n// AES-GCM encrypt data with password, returns base64 string\r\nexport async function aesGcmEncrypt(data, password) {\r\n\tconst enc = new TextEncoder();\r\n\tconst salt = crypto.getRandomValues(new Uint8Array(16));\r\n\tconst iv = crypto.getRandomValues(new Uint8Array(12));\r\n\tconst keyMaterial = await crypto.subtle.importKey(\r\n\t\t\"raw\",\r\n\t\tenc.encode(password),\r\n\t\t{ name: \"PBKDF2\" },\r\n\t\tfalse,\r\n\t\t[\"deriveKey\"]\r\n\t);\r\n\tconst key = await crypto.subtle.deriveKey(\r\n\t\t{\r\n\t\tname: \"PBKDF2\",\r\n\t\tsalt,\r\n\t\titerations: 100000,\r\n\t\thash: \"SHA-256\",\r\n\t\t},\r\n\t\tkeyMaterial,\r\n\t\t{ name: \"AES-GCM\", length: 256 },\r\n\t\tfalse,\r\n\t\t[\"encrypt\"]\r\n\t);\r\n\r\n\tconst dataBuffer = typeof data === \"string\" ? enc.encode(data) : data;\r\n\tconst encrypted = await crypto.subtle.encrypt({ name: \"AES-GCM\", iv }, key, dataBuffer);\r\n\r\n\t// Combine salt + iv + encrypted\r\n\tconst combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);\r\n\tcombined.set(salt, 0);\r\n\tcombined.set(iv, salt.length);\r\n\tcombined.set(new Uint8Array(encrypted), salt.length + iv.length);\r\n\r\n\treturn combined;\r\n}\r\n\r\n\r\n// AES gcm Decryption\r\nexport async function aesGcmDecrypt(input, password) {\r\n    const data = input;\r\n    const salt = data.slice(0, 16);\r\n    const iv = data.slice(16, 28);\r\n    const ciphertext = data.slice(28);\r\n    const enc = new TextEncoder();\r\n    const keyMaterial = await crypto.subtle.importKey(\"raw\", enc.encode(password), { name: \"PBKDF2\" }, false, [\"deriveKey\"]);\r\n    const key = await crypto.subtle.deriveKey(\r\n\t\t{ name: \"PBKDF2\", salt, iterations: 100000, hash: \"SHA-256\" },\r\n\t\tkeyMaterial,\r\n\t\t{ name: \"AES-GCM\", length: 256 },\r\n\t\tfalse,\r\n\t\t[\"decrypt\"]\r\n    );\r\n    const decrypted = await crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, key, ciphertext);\r\n    return new Uint8Array(decrypted); // raw bytes\r\n}\r\n\r\n\r\nexport const hashArgon2 = async (input, iterations = 3, hashToVerify = null, verify = false) => {\r\n\tconst password = typeof input === \"string\" ? input : new TextDecoder().decode(input);\r\n\t\r\n\tif (verify && hashToVerify) {\r\n\t\ttry {\r\n\t\t\tconst result = await window.argon2.verify({\r\n\t\t\tpass: password,\r\n\t\t\tencoded: hashToVerify,\r\n\t\t\ttype: window.argon2.ArgonType.Argon2id,\r\n\t\t});\r\n\t\treturn result;\r\n\t\t} catch (err) {\r\n\t\t\tconsole.error(\"Argon2 verification error:\", err);\r\n\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tconst salt = generateSaltBytes(); \r\n\t\r\n\tconst result = await window.argon2.hash({\r\n\t\tpass: password,\r\n\t\tsalt: salt,\r\n\t\ttime: iterations,\r\n\t\tmem: 1024, // memory in KiB\r\n\t\thashLen: 32,\r\n\t\ttype: window.argon2.ArgonType.Argon2id,\r\n\t});\r\n\r\n\treturn result.encoded;\r\n};\r\n\r\n\r\nexport const rotBytes = (bytes, keyArray, rot = true) => {\r\n    const result = new Uint8Array(bytes.length);\r\n\r\n    for (let i = 0; i < bytes.length; i++) {\r\n\t\tif (rot) {\r\n        \tresult[i] = (bytes[i] + keyArray[i % keyArray.length]) & 0xff;\r\n\t\t} else {\r\n\t\t\t result[i] = (bytes[i] - keyArray[i % keyArray.length] + 256) & 0xff;\r\n\t\t}\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n\r\n// Uses XOR and a hash-based key (hex string)\r\nexport function xorUint8(inputBytes, keyBytes, hash = true) {\r\n\tif (hash) {\r\n\t\tkeyBytes = hexToBytes(keyBytes);\r\n\t}\r\n   \r\n    const result = new Uint8Array(inputBytes.length);\r\n    for (let i = 0; i < inputBytes.length; i++) {\r\n      // XOR again to decrypt\r\n      result[i] = inputBytes[i] ^ keyBytes[i % keyBytes.length];\r\n    }\r\n\r\n    return result; \r\n}\r\n\r\n\r\nexport const rotUint32 = (arr, keyArray, rot = true) => {\r\n    const result = new Uint32Array(arr.length);\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n\t\tif (rot) {\r\n\t\t\tresult[i] = (arr[i] + keyArray[i % keyArray.length]) >>> 0; // wrap around unsigned\r\n\t\t} else {\r\n\t\t\tresult[i] = (arr[i] - keyArray[i % keyArray.length]) >>> 0; \r\n\t\t}\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n\r\nexport const xorUint32 = (data, keyArray) => {\r\n    const result = new Uint32Array(data.length);\r\n\r\n    for (let i = 0; i < data.length; i++) {\r\n        result[i] = data[i] ^ keyArray[i % keyArray.length];\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n\r\n// Add random padding and length markers\r\nexport function expandUint8(uint8) {\r\n\t// two random numbers [0..99]\r\n\tconst frontLen = crypto.getRandomValues(new Uint32Array(1))[0] % 99;\r\n    const backLen = crypto.getRandomValues(new Uint32Array(1))[0] % 99;\r\n\r\n\t// generate random paddings\r\n\tconst frontPad = new Uint8Array(frontLen);\r\n\tconst backPad = new Uint8Array(backLen);\r\n\tcrypto.getRandomValues(frontPad);  // cryptographically strong\r\n\tcrypto.getRandomValues(backPad);\r\n\r\n\tconst combined = new Uint8Array(frontLen + uint8.length + backLen + 2);\r\n\tcombined.set(frontPad, 0);\r\n\tcombined.set(uint8, frontLen);\r\n\tcombined.set(backPad, frontLen + uint8.length);\r\n\r\n\t// store lengths at the end\r\n\tcombined[combined.length - 2] = frontLen;\r\n\tcombined[combined.length - 1] = backLen;\r\n\r\n\treturn combined;\r\n}\r\n\r\n\r\n// Reverse the process and extract the original data\r\nexport function reduceUint8(uint8) {\r\n\tif (uint8.length < 2) throw new Error(\"Invalid data\");\r\n\r\n\tconst frontLen = uint8[uint8.length - 2];\r\n\tconst backLen = uint8[uint8.length - 1];\r\n\r\n\t// slice out the original data\r\n\tconst original = uint8.slice(frontLen, uint8.length - backLen - 2);\r\n\r\n\treturn original;\r\n}\r\n\r\n","import { base64ToUint8, uint8ToBase64 } from './cryptoUtils';\r\nimport JSZip from \"jszip\";\r\nimport jsQR from 'jsqr';\r\n\r\n\r\n/**\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {function(Uint8Array): void} [options.onDataLoaded]\r\n * @param {function(string): void} [options.onBase64]\r\n * @param {function({name, type, size}): void} [options.onFileInfo]\r\n * @param {function(string): void} [options.onText]\r\n */\r\nexport function uploadFile(file, options = {}) {\r\n  const {\r\n    onDataLoaded,     // function(Uint8Array): void\r\n    onBase64,         // function(base64Str): void\r\n    onFileInfo,       // function({ name, type, size }): void\r\n    onText,           // function(utf8String): void\r\n  } = options;\r\n\r\n  const reader = new FileReader();\r\n\r\n  reader.onload = async (e) => {\r\n    try {\r\n      let bytes = new Uint8Array(e.target.result);\r\n\r\n      // Call optional hooks\r\n      if (onDataLoaded) onDataLoaded(bytes);\r\n      if (onBase64) onBase64(uint8ToBase64(bytes));\r\n\r\n      if (onText) {\r\n        try {\r\n            const text = new TextDecoder().decode(bytes);\r\n            onText(text);\r\n        } catch {\r\n            onText(\"[Unreadable binary data]\");\r\n        }\r\n      }\r\n\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n            name: file.name,\r\n            type: file.type || 'unknown',\r\n            size: formatBytes(file.size),\r\n        });\r\n      }\r\n    } catch (err) {\r\n      return { error: \"Failed to process file.\" + err.message };\r\n    }\r\n  };\r\n\r\n  reader.onerror = () => {\r\n    return { error: \"Failed to read file.\" };\r\n  };\r\n\r\n  reader.readAsArrayBuffer(file);\r\n}\r\n\r\n/**\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {function(Uint8Array): void} [options.onDataLoaded]\r\n * @param {function(string): void} [options.onBase64]\r\n * @param {function({name, type, size, ext?: string}): void} [options.onFileInfo]\r\n * @param {function(string): void} [options.onText]\r\n * @param {function(Error): void} [options.onError]\r\n */\r\nexport async function uploadEncFile(file, options = {}) {\r\n  const { onDataLoaded, onBase64, onFileInfo, onText } = options;\r\n\r\n  const isImage = file.type.startsWith(\"image/\");\r\n  const reader = new FileReader();\r\n\r\n  // Helper to read ArrayBuffer or DataURL\r\n  const fileData = await new Promise((resolve, reject) => {\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject(new Error(\"Failed to read file\"));\r\n    if (isImage) {\r\n      reader.readAsDataURL(file);\r\n    } else {\r\n      reader.readAsArrayBuffer(file);\r\n    }\r\n  });\r\n\r\n  try {\r\n    let bytes;\r\n\r\n    if (isImage) {\r\n      // QR decode: await the async image load/processing\r\n      const dataUrl = fileData;\r\n      bytes = await new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.crossOrigin = \"anonymous\";\r\n        img.onload = () => {\r\n          try {\r\n            const canvas = document.createElement(\"canvas\");\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n            const ctx = canvas.getContext(\"2d\");\r\n            ctx.drawImage(img, 0, 0);\r\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n            const info = jsQR(imageData.data, canvas.width, canvas.height);\r\n            if (!info?.data) {\r\n              reject(new Error(\"Invalid or missing QR code\"));\r\n              return;\r\n            }\r\n            resolve(info.data);\r\n          } catch (err) {\r\n            reject(new Error(\"Failed to process QR image: \" + err.message));\r\n          }\r\n        };\r\n        img.onerror = () => reject(new Error(\"Failed to load image\"));\r\n        img.src = dataUrl;\r\n      });\r\n\r\n      if (onText) onText(bytes);\r\n      if (onDataLoaded) onDataLoaded(base64ToUint8(bytes));\r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n          name: file.name,\r\n          type: file.type,\r\n          size: formatBytes(file.size),\r\n        });\r\n      }\r\n      return { success: true };\r\n    } else {\r\n      // Non-image (.ec) branch\r\n      bytes = new Uint8Array(fileData);\r\n\r\n      if (bytes.length < 2 || bytes[0] !== 0xEC || bytes[1] !== 0x01) {\r\n        throw new Error(\"Invalid .ec file\");\r\n      }\r\n\r\n      const data = bytes.slice(2); // strip magic\r\n\r\n      if (onDataLoaded) onDataLoaded(data);\r\n      if (onBase64) onBase64(uint8ToBase64(data));\r\n      if (onText) {\r\n        let text;\r\n        try {\r\n          text = new TextDecoder().decode(data);\r\n        } catch {\r\n          text = \"[Unreadable binary data]\";\r\n        }\r\n        onText(text);\r\n      }\r\n      \r\n      if (onFileInfo) {\r\n        onFileInfo({\r\n          name: file.name,\r\n          type: file.type || \"application/x-ec\",\r\n          size: formatBytes(file.size),\r\n        });\r\n      }\r\n      return { success: true };\r\n    }\r\n  } catch (err) {\r\n    return { error: \"Failed to process file: \" + (err?.message || \"unknown\") };\r\n  }\r\n}\r\n\r\n// returns file size\r\nexport function formatBytes(bytes) {\r\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\"];\r\n  if (bytes === 0) return \"0 Bytes\";\r\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\r\n  return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + \" \" + sizes[i];\r\n}\r\n\r\n// Detects file type if no result returns txt\r\nexport async function detectFileExtension(bytes) {\r\n  // Check for .ec magic number 0xEC01 (first two bytes)\r\n  if (bytes.length >= 2 && bytes[0] === 0xEC && bytes[1] === 0x01) {\r\n    return \"ec\";\r\n  }\r\n\r\n  const hex = [...bytes.slice(0, 8)]\r\n    .map((b) => b.toString(16).padStart(2, \"0\"))\r\n    .join(\"\")\r\n    .toUpperCase();\r\n\r\n  if (hex.startsWith(\"504B0304\")) {\r\n    try {\r\n      const zip = await JSZip.loadAsync(bytes);\r\n      const fileNames = Object.keys(zip.files);\r\n\r\n      if (fileNames.some(name => name.startsWith(\"word/\"))) return \"docx\";\r\n      if (fileNames.some(name => name.startsWith(\"xl/\"))) return \"xlsx\";\r\n      if (fileNames.some(name => name.startsWith(\"ppt/\"))) return \"pptx\";\r\n      \r\n      return \"zip\";\r\n    } catch (e) {\r\n      return \"zip\";\r\n    }\r\n  }\r\n\r\n  // Known binary file signatures\r\n  if (hex.startsWith(\"89504E47\")) return \"png\";\r\n  if (hex.startsWith(\"FFD8FF\")) return \"jpg\";\r\n  if (hex.startsWith(\"25504446\")) return \"pdf\";\r\n  if (hex.startsWith(\"47494638\")) return \"gif\";\r\n  if (hex.includes(\"66747970\")) return \"mp4\";\r\n  if (hex.startsWith(\"52494646\")) return \"wav\";\r\n  if (hex.startsWith(\"000001BA\")) return \"mpg\";\r\n  \r\n  // Check for binary (non-printable control characters)\r\n  const isBinary = bytes.slice(0, 512).some(\r\n    (b) =>\r\n      b < 0x09 || (b > 0x0D && b < 0x20) || b > 0x7E\r\n  );\r\n\r\n  if (isBinary) return \"bin\";\r\n\r\n  // Otherwise, decode as normal text and guess\r\n  const text = new TextDecoder().decode(bytes.slice(0, 1024)).trim();\r\n\r\n  if (text.startsWith(\"{\") || text.startsWith(\"[\")) return \"json\";\r\n  if (text.includes(\",\") && text.match(/\\n|;/)) return \"csv\";\r\n\r\n  return \"txt\";\r\n}\r\n\r\n// random number for files\r\nfunction randomNumber(max = 9999) {\r\n    const date = Date.now().toString().slice(0, 6);\r\n    const rand = Math.floor(Math.random() * max);\r\n    return date + rand;\r\n}\r\n\r\nconst fileId = randomNumber();\r\n\r\n\r\n// saves as .ec file\r\nexport function saveFileAsEc(input, name) {\r\n    if (!name) name = \"\";\r\n    // Magic number (2 bytes): 0xEC01\r\n    const MAGIC_BYTES = new Uint8Array([0xEC, 0x01]);\r\n\r\n    const blob = new Blob([MAGIC_BYTES, input], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.ec`;\r\n    a.click();\r\n}\r\n\r\n\r\n// save file as ext\r\nexport async function saveFileAsExt(input, ext, name) {\r\n    if (!name) name = \"\";\r\n    const blob = new Blob([input], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.${ext}`;\r\n    a.click();\r\n}\r\n\r\n\r\nexport function downloadQrCode(canvas, name) {\r\n    if (!name) name = \"\";\r\n    if (!(canvas instanceof HTMLCanvasElement)) return { error: \"Invalid canvas element.\" };\r\n\r\n    const link = document.createElement('a');\r\n    link.href = canvas.toDataURL('image/png');\r\n    link.download = `${name}${fileId}.png`;\r\n    link.click();    \r\n}\r\n\r\n\r\nexport function saveFileAsEc32(input, name) {\r\n    if (!name) name = \"\";\r\n\r\n    // Magic number (1 element, 32-bit): 0xEC01\r\n    const MAGIC_UINT32 = new Uint32Array([0xEC01]);\r\n\r\n    // Combine header + data into one Uint32Array\r\n    const combined = new Uint32Array(MAGIC_UINT32.length + input.length);\r\n    combined.set(MAGIC_UINT32, 0);\r\n    combined.set(input, MAGIC_UINT32.length);\r\n\r\n    // Save as raw bytes\r\n    const blob = new Blob([combined.buffer], { type: \"application/octet-stream\" });\r\n    const a = document.createElement(\"a\");\r\n    a.href = URL.createObjectURL(blob);\r\n    a.download = `${name}${fileId}.ec32`; // extension for clarity\r\n    a.click();\r\n}\r\n\r\n\r\n// Upload and parse a .ec32 file (Uint32Array format with 32-bit magic).\r\nexport async function uploadEncFile32(file, options = {}) {\r\n  const { onUint32, onInt32, onText, onTextInt, onFileInfo } = options;\r\n\r\n  const reader = new FileReader();\r\n  const fileData = await new Promise((resolve, reject) => {\r\n    reader.onload = () => resolve(reader.result);\r\n    reader.onerror = () => reject(new Error(\"Failed to read file\"));\r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n\r\n  try {\r\n    const uint32 = new Uint32Array(fileData);\r\n    const int32 = new Int32Array(fileData);\r\n\r\n    if (uint32.length < 1 || uint32[0] !== 0xEC01) {\r\n      throw new Error(\"Invalid .ec32 file (missing magic number)\");\r\n    }\r\n    if (int32.length < 1 || int32[0] !== 0xEC01) {\r\n      throw new Error(\"Invalid .ec32 file (missing magic number)\");\r\n    }\r\n\r\n    const uintData = uint32.slice(1); // strip 32-bit magic\r\n    const intKey = int32.slice(1); // strip 32-bit magic\r\n\r\n    if (onUint32) onUint32(uintData);\r\n    if (onInt32) onInt32(intKey);\r\n\r\n    if (onText) {\r\n      let text;\r\n      try {\r\n        text = new TextDecoder().decode(new Uint8Array(uintData.buffer));\r\n      } catch {\r\n        text = \"[Unreadable binary data]\";\r\n      }\r\n      onText(text);\r\n    }\r\n\r\n    if (onTextInt) {\r\n      let text;\r\n      try {\r\n        text = Array.from(intKey).join(\",\");\r\n      } catch {\r\n        text = \"[Unreadable binary data]\";\r\n      }\r\n      onTextInt(text);\r\n    }\r\n\r\n    if (onFileInfo) {\r\n      onFileInfo({\r\n        name: file.name,\r\n        type: file.type || \"application/x-ec32\",\r\n        size: file.size,\r\n        ext: \".ec32\",\r\n      });\r\n    }\r\n\r\n    return { success: true };\r\n  } catch (err) {\r\n    return { error: \"Failed to process file: \" + (err?.message || \"unknown\") };\r\n  }\r\n}","import { randomizer, expandUint8, uint8ToUint32, uint32ToUint8, reduceUint8 } from '../utils/cryptoUtils';\r\nimport { detectFileExtension } from '../utils/fileUtils';\r\n/* eslint-env worker */\r\n/* eslint-disable no-restricted-globals */\r\n\r\nself.addEventListener(\"message\", async (e) => {\r\n    const { type, load } = e.data;\r\n\r\n    if (type === \"shuffle\") {\r\n        const { uint8, allChar } = load;\r\n        \r\n        if (!uint8) {\r\n            return self.postMessage({ type: \"error\", error: \"No input provided.\" });\r\n        }\r\n\r\n        try {\r\n            const expanded = expandUint8(uint8);\r\n            const uint32View = uint8ToUint32(expanded);\r\n\r\n            const { shuffled, key } = quantShuffle32(uint32View, allChar);\r\n        \r\n            self.postMessage({\r\n                type: \"done-shuffle\",\r\n                result: { shuffled, key },\r\n            });\r\n        } catch (err) {\r\n            self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n        }\r\n\r\n    } else if (type === \"unshuffle\") {\r\n        let { shuffled, key } = load;\r\n\r\n        try {\r\n            const unshuffled = quantUnshuffle32(shuffled, key);\r\n            \r\n            const uint8 = uint32ToUint8(unshuffled);\r\n            const origin = reduceUint8(uint8);\r\n        \r\n            const ext = await detectFileExtension(origin);\r\n\r\n            self.postMessage({\r\n                type: \"done-unshuffle\",\r\n                result: { origin, ext},\r\n            });\r\n        } catch (err) {\r\n            self.postMessage({ type: \"error\", error: err?.message ?? String(err) });\r\n        }\r\n    }\r\n});\r\n\r\n\r\n\r\n// Quantum shuffle function (Uint32Array)\r\nexport function quantShuffle32(input, allChar = false) {\r\n    const shuffled = new Uint32Array(input.length);\r\n    const key = new Int32Array(input.length);\r\n\r\n    for (let i = 0; i < input.length; i++) {\r\n        const rotation = randomizer(allChar, true);\r\n        key[i] = rotation;\r\n        shuffled[i] = input[i] + rotation;\r\n    }\r\n\r\n    return { shuffled, key };\r\n}\r\n\r\n// Reverse shuffle\r\nexport function quantUnshuffle32(shuffled, key) {\r\n    const original = new Uint32Array(shuffled.length);\r\n\r\n    for (let i = 0; i < shuffled.length; i++) {\r\n        original[i] = shuffled[i] - key[i];\r\n    }\r\n\r\n    return original;\r\n}\r\n"],"names":["randomizer","allChar","randUint32","arr","Uint32Array","crypto","getRandomValues","value","arguments","length","undefined","Uint8Array","max","Date","now","toString","slice","Math","floor","random","randomNumber","self","addEventListener","async","type","load","e","data","uint8","postMessage","error","expanded","frontLen","backLen","frontPad","backPad","combined","set","expandUint8","uint32View","bytes","paddedLength","ceil","padded","uint32Array","i","uint8ToUint32","shuffled","key","input","Int32Array","rotation","quantShuffle32","result","err","_err$message","message","String","unshuffled","original","quantUnshuffle32","origin","Error","reduceUint8","Array","isArray","parts","split","map","n","parseInt","trim","some","isNaN","originalLength","val","offset","subarray","uint32ToUint8","ext","hex","b","padStart","join","toUpperCase","startsWith","zip","JSZip","fileNames","Object","keys","files","name","includes","text","TextDecoder","decode","match","detectFileExtension","_err$message2"],"sourceRoot":""}